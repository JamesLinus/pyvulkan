
/*
* 
* THIS FILE IS GENERATED BY genswigi.py 
*
* pyvulkan SWIG interface description file
*
* Copyright (C) 2016 by VLAM3D Software inc. https://www.vlam3d.com
*
* This code is licensed under the MIT license (MIT) (http://opensource.org/licenses/MIT)
*/

/*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

// Begin content generated by genswigi.py
const char* vkGetErrorString(VkResult retval);


#define VK_VERSION_1_0 1
#include "vk_platform.h"

#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0)

// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)
#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)
#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)
// Version of this file
#define VK_HEADER_VERSION 30


#define VK_NULL_HANDLE 0
        


#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;


#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif
        


typedef uint32_t VkFlags;
typedef uint32_t VkBool32;
typedef uint64_t VkDeviceSize;
typedef uint32_t VkSampleMask;

VK_DEFINE_HANDLE(VkInstance)
VK_DEFINE_HANDLE(VkPhysicalDevice)
VK_DEFINE_HANDLE(VkDevice)
VK_DEFINE_HANDLE(VkQueue)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)

#define VK_LOD_CLAMP_NONE                 1000.0f
#define VK_REMAINING_MIP_LEVELS           (~0U)
#define VK_REMAINING_ARRAY_LAYERS         (~0U)
#define VK_WHOLE_SIZE                     (~0ULL)
#define VK_ATTACHMENT_UNUSED              (~0U)
#define VK_TRUE                           1
#define VK_FALSE                          0
#define VK_QUEUE_FAMILY_IGNORED           (~0U)
#define VK_SUBPASS_EXTERNAL               (~0U)
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  256
#define VK_UUID_SIZE                      16
#define VK_MAX_MEMORY_TYPES               32
#define VK_MAX_MEMORY_HEAPS               16
#define VK_MAX_EXTENSION_NAME_SIZE        256
#define VK_MAX_DESCRIPTION_SIZE           256


typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (VK_PIPELINE_CACHE_HEADER_VERSION_ONE - VK_PIPELINE_CACHE_HEADER_VERSION_ONE + 1),
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCacheHeaderVersion;

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_RESULT_BEGIN_RANGE = VK_ERROR_FRAGMENTED_POOL,
    VK_RESULT_END_RANGE = VK_INCOMPLETE,
    VK_RESULT_RANGE_SIZE = (VK_INCOMPLETE - VK_ERROR_FRAGMENTED_POOL + 1),
    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
} VkResult;

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_BEGIN_RANGE = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    VK_STRUCTURE_TYPE_END_RANGE = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_RANGE_SIZE = (VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - VK_STRUCTURE_TYPE_APPLICATION_INFO + 1),
    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkStructureType;

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - VK_SYSTEM_ALLOCATION_SCOPE_COMMAND + 1),
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
} VkSystemAllocationScope;

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1),
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkInternalAllocationType;

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_BEGIN_RANGE = VK_FORMAT_UNDEFINED,
    VK_FORMAT_END_RANGE = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    VK_FORMAT_RANGE_SIZE = (VK_FORMAT_ASTC_12x12_SRGB_BLOCK - VK_FORMAT_UNDEFINED + 1),
    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
} VkFormat;

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_BEGIN_RANGE = VK_IMAGE_TYPE_1D,
    VK_IMAGE_TYPE_END_RANGE = VK_IMAGE_TYPE_3D,
    VK_IMAGE_TYPE_RANGE_SIZE = (VK_IMAGE_TYPE_3D - VK_IMAGE_TYPE_1D + 1),
    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageType;

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_BEGIN_RANGE = VK_IMAGE_TILING_OPTIMAL,
    VK_IMAGE_TILING_END_RANGE = VK_IMAGE_TILING_LINEAR,
    VK_IMAGE_TILING_RANGE_SIZE = (VK_IMAGE_TILING_LINEAR - VK_IMAGE_TILING_OPTIMAL + 1),
    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
} VkImageTiling;

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_PHYSICAL_DEVICE_TYPE_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_CPU,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (VK_PHYSICAL_DEVICE_TYPE_CPU - VK_PHYSICAL_DEVICE_TYPE_OTHER + 1),
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkPhysicalDeviceType;

typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_BEGIN_RANGE = VK_QUERY_TYPE_OCCLUSION,
    VK_QUERY_TYPE_END_RANGE = VK_QUERY_TYPE_TIMESTAMP,
    VK_QUERY_TYPE_RANGE_SIZE = (VK_QUERY_TYPE_TIMESTAMP - VK_QUERY_TYPE_OCCLUSION + 1),
    VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkQueryType;

typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_BEGIN_RANGE = VK_SHARING_MODE_EXCLUSIVE,
    VK_SHARING_MODE_END_RANGE = VK_SHARING_MODE_CONCURRENT,
    VK_SHARING_MODE_RANGE_SIZE = (VK_SHARING_MODE_CONCURRENT - VK_SHARING_MODE_EXCLUSIVE + 1),
    VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSharingMode;

typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_BEGIN_RANGE = VK_IMAGE_LAYOUT_UNDEFINED,
    VK_IMAGE_LAYOUT_END_RANGE = VK_IMAGE_LAYOUT_PREINITIALIZED,
    VK_IMAGE_LAYOUT_RANGE_SIZE = (VK_IMAGE_LAYOUT_PREINITIALIZED - VK_IMAGE_LAYOUT_UNDEFINED + 1),
    VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
} VkImageLayout;

typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_1D,
    VK_IMAGE_VIEW_TYPE_END_RANGE = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = (VK_IMAGE_VIEW_TYPE_CUBE_ARRAY - VK_IMAGE_VIEW_TYPE_1D + 1),
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageViewType;

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_IDENTITY,
    VK_COMPONENT_SWIZZLE_END_RANGE = VK_COMPONENT_SWIZZLE_A,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = (VK_COMPONENT_SWIZZLE_A - VK_COMPONENT_SWIZZLE_IDENTITY + 1),
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
} VkComponentSwizzle;

typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_VERTEX,
    VK_VERTEX_INPUT_RATE_END_RANGE = VK_VERTEX_INPUT_RATE_INSTANCE,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = (VK_VERTEX_INPUT_RATE_INSTANCE - VK_VERTEX_INPUT_RATE_VERTEX + 1),
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
} VkVertexInputRate;

typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    VK_PRIMITIVE_TOPOLOGY_END_RANGE = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = (VK_PRIMITIVE_TOPOLOGY_PATCH_LIST - VK_PRIMITIVE_TOPOLOGY_POINT_LIST + 1),
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
} VkPrimitiveTopology;

typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_BEGIN_RANGE = VK_POLYGON_MODE_FILL,
    VK_POLYGON_MODE_END_RANGE = VK_POLYGON_MODE_POINT,
    VK_POLYGON_MODE_RANGE_SIZE = (VK_POLYGON_MODE_POINT - VK_POLYGON_MODE_FILL + 1),
    VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
} VkPolygonMode;

typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_BEGIN_RANGE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    VK_FRONT_FACE_END_RANGE = VK_FRONT_FACE_CLOCKWISE,
    VK_FRONT_FACE_RANGE_SIZE = (VK_FRONT_FACE_CLOCKWISE - VK_FRONT_FACE_COUNTER_CLOCKWISE + 1),
    VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
} VkFrontFace;

typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_BEGIN_RANGE = VK_COMPARE_OP_NEVER,
    VK_COMPARE_OP_END_RANGE = VK_COMPARE_OP_ALWAYS,
    VK_COMPARE_OP_RANGE_SIZE = (VK_COMPARE_OP_ALWAYS - VK_COMPARE_OP_NEVER + 1),
    VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
} VkCompareOp;

typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_BEGIN_RANGE = VK_STENCIL_OP_KEEP,
    VK_STENCIL_OP_END_RANGE = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    VK_STENCIL_OP_RANGE_SIZE = (VK_STENCIL_OP_DECREMENT_AND_WRAP - VK_STENCIL_OP_KEEP + 1),
    VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
} VkStencilOp;

typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_BEGIN_RANGE = VK_LOGIC_OP_CLEAR,
    VK_LOGIC_OP_END_RANGE = VK_LOGIC_OP_SET,
    VK_LOGIC_OP_RANGE_SIZE = (VK_LOGIC_OP_SET - VK_LOGIC_OP_CLEAR + 1),
    VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
} VkLogicOp;

typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_BEGIN_RANGE = VK_BLEND_FACTOR_ZERO,
    VK_BLEND_FACTOR_END_RANGE = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    VK_BLEND_FACTOR_RANGE_SIZE = (VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - VK_BLEND_FACTOR_ZERO + 1),
    VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
} VkBlendFactor;

typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_BEGIN_RANGE = VK_BLEND_OP_ADD,
    VK_BLEND_OP_END_RANGE = VK_BLEND_OP_MAX,
    VK_BLEND_OP_RANGE_SIZE = (VK_BLEND_OP_MAX - VK_BLEND_OP_ADD + 1),
    VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
} VkBlendOp;

typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_BEGIN_RANGE = VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_END_RANGE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    VK_DYNAMIC_STATE_RANGE_SIZE = (VK_DYNAMIC_STATE_STENCIL_REFERENCE - VK_DYNAMIC_STATE_VIEWPORT + 1),
    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
} VkDynamicState;

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_BEGIN_RANGE = VK_FILTER_NEAREST,
    VK_FILTER_END_RANGE = VK_FILTER_LINEAR,
    VK_FILTER_RANGE_SIZE = (VK_FILTER_LINEAR - VK_FILTER_NEAREST + 1),
    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
} VkFilter;

typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    VK_SAMPLER_MIPMAP_MODE_END_RANGE = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = (VK_SAMPLER_MIPMAP_MODE_LINEAR - VK_SAMPLER_MIPMAP_MODE_NEAREST + 1),
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerMipmapMode;

typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    VK_SAMPLER_ADDRESS_MODE_END_RANGE = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = (VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER - VK_SAMPLER_ADDRESS_MODE_REPEAT + 1),
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerAddressMode;

typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_BEGIN_RANGE = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VK_BORDER_COLOR_END_RANGE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    VK_BORDER_COLOR_RANGE_SIZE = (VK_BORDER_COLOR_INT_OPAQUE_WHITE - VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1),
    VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
} VkBorderColor;

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_SAMPLER,
    VK_DESCRIPTOR_TYPE_END_RANGE = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT - VK_DESCRIPTOR_TYPE_SAMPLER + 1),
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorType;

typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_LOAD,
    VK_ATTACHMENT_LOAD_OP_END_RANGE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = (VK_ATTACHMENT_LOAD_OP_DONT_CARE - VK_ATTACHMENT_LOAD_OP_LOAD + 1),
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentLoadOp;

typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_STORE,
    VK_ATTACHMENT_STORE_OP_END_RANGE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = (VK_ATTACHMENT_STORE_OP_DONT_CARE - VK_ATTACHMENT_STORE_OP_STORE + 1),
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentStoreOp;

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_GRAPHICS,
    VK_PIPELINE_BIND_POINT_END_RANGE = VK_PIPELINE_BIND_POINT_COMPUTE,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = (VK_PIPELINE_BIND_POINT_COMPUTE - VK_PIPELINE_BIND_POINT_GRAPHICS + 1),
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
} VkPipelineBindPoint;

typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + 1),
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferLevel;

typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_BEGIN_RANGE = VK_INDEX_TYPE_UINT16,
    VK_INDEX_TYPE_END_RANGE = VK_INDEX_TYPE_UINT32,
    VK_INDEX_TYPE_RANGE_SIZE = (VK_INDEX_TYPE_UINT32 - VK_INDEX_TYPE_UINT16 + 1),
    VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkIndexType;

typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_BEGIN_RANGE = VK_SUBPASS_CONTENTS_INLINE,
    VK_SUBPASS_CONTENTS_END_RANGE = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = (VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - VK_SUBPASS_CONTENTS_INLINE + 1),
    VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassContents;

typedef VkFlags VkInstanceCreateFlags;

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFormatFeatureFlagBits;
typedef VkFlags VkFormatFeatureFlags;

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageUsageFlagBits;
typedef VkFlags VkImageUsageFlags;

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageCreateFlagBits;
typedef VkFlags VkImageCreateFlags;

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSampleCountFlagBits;
typedef VkFlags VkSampleCountFlags;

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
typedef VkFlags VkQueueFlags;

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryPropertyFlagBits;
typedef VkFlags VkMemoryPropertyFlags;

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryHeapFlagBits;
typedef VkFlags VkMemoryHeapFlags;
typedef VkFlags VkDeviceCreateFlags;
typedef VkFlags VkDeviceQueueCreateFlags;

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineStageFlagBits;
typedef VkFlags VkPipelineStageFlags;
typedef VkFlags VkMemoryMapFlags;

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageAspectFlagBits;
typedef VkFlags VkImageAspectFlags;

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseImageFormatFlagBits;
typedef VkFlags VkSparseImageFormatFlags;

typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseMemoryBindFlagBits;
typedef VkFlags VkSparseMemoryBindFlags;

typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceCreateFlagBits;
typedef VkFlags VkFenceCreateFlags;
typedef VkFlags VkSemaphoreCreateFlags;
typedef VkFlags VkEventCreateFlags;
typedef VkFlags VkQueryPoolCreateFlags;

typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryPipelineStatisticFlagBits;
typedef VkFlags VkQueryPipelineStatisticFlags;

typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 0x00000001,
    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryResultFlagBits;
typedef VkFlags VkQueryResultFlags;

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferCreateFlagBits;
typedef VkFlags VkBufferCreateFlags;

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferUsageFlagBits;
typedef VkFlags VkBufferUsageFlags;
typedef VkFlags VkBufferViewCreateFlags;
typedef VkFlags VkImageViewCreateFlags;
typedef VkFlags VkShaderModuleCreateFlags;
typedef VkFlags VkPipelineCacheCreateFlags;

typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCreateFlagBits;
typedef VkFlags VkPipelineCreateFlags;
typedef VkFlags VkPipelineShaderStageCreateFlags;

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderStageFlagBits;
typedef VkFlags VkPipelineVertexInputStateCreateFlags;
typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
typedef VkFlags VkPipelineTessellationStateCreateFlags;
typedef VkFlags VkPipelineViewportStateCreateFlags;
typedef VkFlags VkPipelineRasterizationStateCreateFlags;

typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 0x00000001,
    VK_CULL_MODE_BACK_BIT = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCullModeFlagBits;
typedef VkFlags VkCullModeFlags;
typedef VkFlags VkPipelineMultisampleStateCreateFlags;
typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
typedef VkFlags VkPipelineColorBlendStateCreateFlags;

typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkColorComponentFlagBits;
typedef VkFlags VkColorComponentFlags;
typedef VkFlags VkPipelineDynamicStateCreateFlags;
typedef VkFlags VkPipelineLayoutCreateFlags;
typedef VkFlags VkShaderStageFlags;
typedef VkFlags VkSamplerCreateFlags;
typedef VkFlags VkDescriptorSetLayoutCreateFlags;

typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorPoolCreateFlagBits;
typedef VkFlags VkDescriptorPoolCreateFlags;
typedef VkFlags VkDescriptorPoolResetFlags;
typedef VkFlags VkFramebufferCreateFlags;
typedef VkFlags VkRenderPassCreateFlags;

typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentDescriptionFlagBits;
typedef VkFlags VkAttachmentDescriptionFlags;
typedef VkFlags VkSubpassDescriptionFlags;

typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
    VK_ACCESS_HOST_READ_BIT = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAccessFlagBits;
typedef VkFlags VkAccessFlags;

typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDependencyFlagBits;
typedef VkFlags VkDependencyFlags;

typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolCreateFlagBits;
typedef VkFlags VkCommandPoolCreateFlags;

typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolResetFlagBits;
typedef VkFlags VkCommandPoolResetFlags;

typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferUsageFlagBits;
typedef VkFlags VkCommandBufferUsageFlags;

typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryControlFlagBits;
typedef VkFlags VkQueryControlFlags;

typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferResetFlagBits;
typedef VkFlags VkCommandBufferResetFlags;

typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
    VK_STENCIL_FRONT_AND_BACK = 0x00000003,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkStencilFaceFlagBits;
typedef VkFlags VkStencilFaceFlags;

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);

typedef struct VkApplicationInfo {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pApplicationName;
    uint32_t           applicationVersion;
    const char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo;

struct VkApplicationInfoRAII {
   VkApplicationInfo nonRaiiObj;
    std::string                                 strApplicationName;
    std::string                                 strEngineName;
};

typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkInstanceCreateFlags       flags;
    const VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    const char* const*          ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    const char* const*          ppEnabledExtensionNames;
} VkInstanceCreateInfo;

struct VkInstanceCreateInfoRAII {
   VkInstanceCreateInfo nonRaiiObj;
    std::shared_ptr<VkApplicationInfoRAII>      pApplicationInfo;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
};

typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;

typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;

typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;

typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;

typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;

typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;

typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;

typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;

typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;

struct VkDeviceQueueCreateInfoRAII {
   VkDeviceQueueCreateInfo nonRaiiObj;
    std::vector<float>                          vecQueuePriorities;
};

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;

struct VkDeviceCreateInfoRAII {
   VkDeviceCreateInfo nonRaiiObj;
    std::vector<VkDeviceQueueCreateInfo>        vecQueueCreateInfos;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
    std::shared_ptr<VkPhysicalDeviceFeatures>   pEnabledFeatures;
};

typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties;

typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;

typedef struct VkSubmitInfo {
    VkStructureType                sType;
    const void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    const VkSemaphore*             pWaitSemaphores;
    const VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    const VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    const VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo;

struct VkSubmitInfoRAII {
   VkSubmitInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkPipelineStageFlags>           vecWaitDstStageMask;
    std::vector<VkCommandBuffer>                vecCommandBuffers;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;

typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;

typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;

typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind;

typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo;

struct VkSparseBufferMemoryBindInfoRAII {
   VkSparseBufferMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo;

struct VkSparseImageOpaqueMemoryBindInfoRAII {
   VkSparseImageOpaqueMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource;

typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D;

typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind;

typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    const VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo;

struct VkSparseImageMemoryBindInfoRAII {
   VkSparseImageMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseImageMemoryBind>        vecBinds;
};

typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    const VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    const VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    const VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    const VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    const VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo;

struct VkBindSparseInfoRAII {
   VkBindSparseInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSparseBufferMemoryBindInfo>   vecBufferBinds;
    std::vector<VkSparseImageOpaqueMemoryBindInfo>vecImageOpaqueBinds;
    std::vector<VkSparseImageMemoryBindInfo>    vecImageBinds;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo;

typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    const void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo;

typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo;

typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo;

typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    const uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo;

struct VkBufferCreateInfoRAII {
   VkBufferCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo;

typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    const uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;

struct VkImageCreateInfoRAII {
   VkImageCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout;

typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;

typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange;

typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;

typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    const void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    const uint32_t*              pCode;
} VkShaderModuleCreateInfo;

typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    const void*                   pInitialData;
} VkPipelineCacheCreateInfo;

typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry;

typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    const VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    const void*                        pData;
} VkSpecializationInfo;

struct VkSpecializationInfoRAII {
   VkSpecializationInfo nonRaiiObj;
    std::vector<VkSpecializationMapEntry>       vecMapEntries;
};

typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    const void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    const char*                         pName;
    const VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;

struct VkPipelineShaderStageCreateInfoRAII {
   VkPipelineShaderStageCreateInfo nonRaiiObj;
    std::string                                 strName;
    std::shared_ptr<VkSpecializationInfoRAII>   pSpecializationInfo;
};

typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;

typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription;

typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;

struct VkPipelineVertexInputStateCreateInfoRAII {
   VkPipelineVertexInputStateCreateInfo nonRaiiObj;
    std::vector<VkVertexInputBindingDescription>vecVertexBindingDescriptions;
    std::vector<VkVertexInputAttributeDescription>vecVertexAttributeDescriptions;
};

typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;

typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo;

typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport;

typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;

typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;

typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;

typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    const VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    const VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;

struct VkPipelineViewportStateCreateInfoRAII {
   VkPipelineViewportStateCreateInfo nonRaiiObj;
    std::vector<VkViewport>                     vecViewports;
    std::vector<VkRect2D>                       vecScissors;
};

typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;

typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    const VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;

typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState;

typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;

typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;

typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    const void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    const VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;

struct VkPipelineColorBlendStateCreateInfoRAII {
   VkPipelineColorBlendStateCreateInfo nonRaiiObj;
    std::vector<VkPipelineColorBlendAttachmentState>vecAttachments;
};

typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    const VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo;

struct VkPipelineDynamicStateCreateInfoRAII {
   VkPipelineDynamicStateCreateInfo nonRaiiObj;
    std::vector<VkDynamicState>                 vecDynamicStates;
};

typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    const void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    const VkPipelineShaderStageCreateInfo*           pStages;
    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    const VkPipelineTessellationStateCreateInfo*     pTessellationState;
    const VkPipelineViewportStateCreateInfo*         pViewportState;
    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    const VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo;

struct VkGraphicsPipelineCreateInfoRAII {
   VkGraphicsPipelineCreateInfo nonRaiiObj;
    std::vector<VkPipelineShaderStageCreateInfo>vecStages;
    std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>pVertexInputState;
    std::shared_ptr<VkPipelineInputAssemblyStateCreateInfo>pInputAssemblyState;
    std::shared_ptr<VkPipelineTessellationStateCreateInfo>pTessellationState;
    std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>pViewportState;
    std::shared_ptr<VkPipelineRasterizationStateCreateInfo>pRasterizationState;
    std::shared_ptr<VkPipelineMultisampleStateCreateInfo>pMultisampleState;
    std::shared_ptr<VkPipelineDepthStencilStateCreateInfo>pDepthStencilState;
    std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>pColorBlendState;
    std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>pDynamicState;
};

typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo;

typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;

typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    const VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    const VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;

struct VkPipelineLayoutCreateInfoRAII {
   VkPipelineLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
    std::vector<VkPushConstantRange>            vecPushConstantRanges;
};

typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo;

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    const VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

struct VkDescriptorSetLayoutBindingRAII {
   VkDescriptorSetLayoutBinding nonRaiiObj;
    std::vector<VkSampler>                      vecImmutableSamplers;
};

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    const void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    const VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;

struct VkDescriptorSetLayoutCreateInfoRAII {
   VkDescriptorSetLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayoutBinding>   vecBindings;
};

typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;

typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    const void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    const VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;

struct VkDescriptorPoolCreateInfoRAII {
   VkDescriptorPoolCreateInfo nonRaiiObj;
    std::vector<VkDescriptorPoolSize>           vecPoolSizes;
};

typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    const VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;

struct VkDescriptorSetAllocateInfoRAII {
   VkDescriptorSetAllocateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
};

typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;

typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;

typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    const void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    const VkDescriptorImageInfo*     pImageInfo;
    const VkDescriptorBufferInfo*    pBufferInfo;
    const VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;

struct VkWriteDescriptorSetRAII {
   VkWriteDescriptorSet nonRaiiObj;
    std::vector<VkDescriptorImageInfo>          vecImageInfo;
    std::vector<VkDescriptorBufferInfo>         vecBufferInfo;
    std::vector<VkBufferView>                   vecTexelBufferView;
};

typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    const void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;

typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    const VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo;

struct VkFramebufferCreateInfoRAII {
   VkFramebufferCreateInfo nonRaiiObj;
    std::vector<VkImageView>                    vecAttachments;
};

typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription;

typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference;

typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    const VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    const VkAttachmentReference*    pColorAttachments;
    const VkAttachmentReference*    pResolveAttachments;
    const VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    const uint32_t*                 pPreserveAttachments;
} VkSubpassDescription;

struct VkSubpassDescriptionRAII {
   VkSubpassDescription nonRaiiObj;
    std::vector<VkAttachmentReference>          vecInputAttachments;
    std::vector<VkAttachmentReference>          vecColorAttachments;
    std::vector<VkAttachmentReference>          vecResolveAttachments;
    std::shared_ptr<VkAttachmentReference>      pDepthStencilAttachment;
    std::vector<uint32_t>                       vecPreserveAttachments;
};

typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency;

typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    const VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    const VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    const VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;

struct VkRenderPassCreateInfoRAII {
   VkRenderPassCreateInfo nonRaiiObj;
    std::vector<VkAttachmentDescription>        vecAttachments;
    std::vector<VkSubpassDescription>           vecSubpasses;
    std::vector<VkSubpassDependency>            vecDependencies;
};

typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo;

typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo;

typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo;

typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    const VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;

struct VkCommandBufferBeginInfoRAII {
   VkCommandBufferBeginInfo nonRaiiObj;
    std::shared_ptr<VkCommandBufferInheritanceInfo>pInheritanceInfo;
};

typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy;

typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers;

typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy;

typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit;

typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy;

typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue;

typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue;

typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue;

typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment;

typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect;

typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve;

typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier;

typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier;

typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    const void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;

typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    const VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;

struct VkRenderPassBeginInfoRAII {
   VkRenderPassBeginInfo nonRaiiObj;
    std::vector<VkClearValue>                   vecClearValues;
};

typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand;

typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;

typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;


typedef VkResult (VKAPI_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
typedef void (VKAPI_PTR *PFN_vkDestroyInstance)(VkInstance instance, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
typedef void (VKAPI_PTR *PFN_vkDestroyDevice)(VkDevice device, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
typedef VkResult (VKAPI_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateMemory)(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
typedef void (VKAPI_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
typedef VkResult (VKAPI_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
typedef void (VKAPI_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFence)(VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef void (VKAPI_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphore)(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
typedef void (VKAPI_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateEvent)(VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
typedef void (VKAPI_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkCreateQueryPool)(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
typedef void (VKAPI_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBuffer)(VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferView)(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImage)(VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage);
typedef void (VKAPI_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImageView)(VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateShaderModule)(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
typedef void (VKAPI_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineCache)(VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
typedef VkResult (VKAPI_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches);
typedef VkResult (VKAPI_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef VkResult (VKAPI_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef void (VKAPI_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSampler)(VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
typedef void (VKAPI_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets);
typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFramebuffer)(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass)(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
typedef void (VKAPI_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
typedef VkResult (VKAPI_PTR *PFN_vkCreateCommandPool)(VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
typedef void (VKAPI_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);
typedef VkResult (VKAPI_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo);
typedef VkResult (VKAPI_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
typedef void (VKAPI_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports);
typedef void (VKAPI_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors);
typedef void (VKAPI_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
typedef void (VKAPI_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, const float blendConstants[4]);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t x, uint32_t y, uint32_t z);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdUpdateBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData);
typedef void (VKAPI_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
typedef void (VKAPI_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects);
typedef void (VKAPI_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues);
typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);

std::shared_ptr<VkApplicationInfoRAII> ApplicationInfo(
    const std::string &                         strApplicationName,
    uint32_t                                    applicationVersion,
    const std::string &                         strEngineName,
    uint32_t                                    engineVersion,
    uint32_t                                    apiVersion);


std::shared_ptr<VkInstanceCreateInfoRAII> InstanceCreateInfo(
    VkInstanceCreateFlags                       flags,
    const std::shared_ptr<VkApplicationInfoRAII> &pApplicationInfo,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames);


VkAllocationCallbacks AllocationCallbacks(
    PFN_vkAllocationFunction                    pfnAllocation,
    PFN_vkReallocationFunction                  pfnReallocation,
    PFN_vkFreeFunction                          pfnFree,
    PFN_vkInternalAllocationNotification        pfnInternalAllocation,
    PFN_vkInternalFreeNotification              pfnInternalFree);


std::shared_ptr<VkInstance_T> createInstance(
        const VkInstanceCreateInfo & pCreateInfo);

std::vector< VkPhysicalDevice > enumeratePhysicalDevices(
        VkInstance instance);

VkPhysicalDeviceFeatures PhysicalDeviceFeatures(
    VkBool32                                    robustBufferAccess,
    VkBool32                                    fullDrawIndexUint32,
    VkBool32                                    imageCubeArray,
    VkBool32                                    independentBlend,
    VkBool32                                    geometryShader,
    VkBool32                                    tessellationShader,
    VkBool32                                    sampleRateShading,
    VkBool32                                    dualSrcBlend,
    VkBool32                                    logicOp,
    VkBool32                                    multiDrawIndirect,
    VkBool32                                    drawIndirectFirstInstance,
    VkBool32                                    depthClamp,
    VkBool32                                    depthBiasClamp,
    VkBool32                                    fillModeNonSolid,
    VkBool32                                    depthBounds,
    VkBool32                                    wideLines,
    VkBool32                                    largePoints,
    VkBool32                                    alphaToOne,
    VkBool32                                    multiViewport,
    VkBool32                                    samplerAnisotropy,
    VkBool32                                    textureCompressionETC2,
    VkBool32                                    textureCompressionASTC_LDR,
    VkBool32                                    textureCompressionBC,
    VkBool32                                    occlusionQueryPrecise,
    VkBool32                                    pipelineStatisticsQuery,
    VkBool32                                    vertexPipelineStoresAndAtomics,
    VkBool32                                    fragmentStoresAndAtomics,
    VkBool32                                    shaderTessellationAndGeometryPointSize,
    VkBool32                                    shaderImageGatherExtended,
    VkBool32                                    shaderStorageImageExtendedFormats,
    VkBool32                                    shaderStorageImageMultisample,
    VkBool32                                    shaderStorageImageReadWithoutFormat,
    VkBool32                                    shaderStorageImageWriteWithoutFormat,
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing,
    VkBool32                                    shaderSampledImageArrayDynamicIndexing,
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing,
    VkBool32                                    shaderStorageImageArrayDynamicIndexing,
    VkBool32                                    shaderClipDistance,
    VkBool32                                    shaderCullDistance,
    VkBool32                                    shaderFloat64,
    VkBool32                                    shaderInt64,
    VkBool32                                    shaderInt16,
    VkBool32                                    shaderResourceResidency,
    VkBool32                                    shaderResourceMinLod,
    VkBool32                                    sparseBinding,
    VkBool32                                    sparseResidencyBuffer,
    VkBool32                                    sparseResidencyImage2D,
    VkBool32                                    sparseResidencyImage3D,
    VkBool32                                    sparseResidency2Samples,
    VkBool32                                    sparseResidency4Samples,
    VkBool32                                    sparseResidency8Samples,
    VkBool32                                    sparseResidency16Samples,
    VkBool32                                    sparseResidencyAliased,
    VkBool32                                    variableMultisampleRate,
    VkBool32                                    inheritedQueries);


VkPhysicalDeviceFeatures getPhysicalDeviceFeatures(
        VkPhysicalDevice physicalDevice);

VkFormatProperties FormatProperties(
    VkFormatFeatureFlags                        linearTilingFeatures,
    VkFormatFeatureFlags                        optimalTilingFeatures,
    VkFormatFeatureFlags                        bufferFeatures);


VkFormatProperties getPhysicalDeviceFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format);

VkExtent3D Extent3D(
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth);


VkImageFormatProperties ImageFormatProperties(
    VkExtent3D                                  maxExtent,
    uint32_t                                    maxMipLevels,
    uint32_t                                    maxArrayLayers,
    VkSampleCountFlags                          sampleCounts,
    VkDeviceSize                                maxResourceSize);


VkImageFormatProperties getPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags);

VkPhysicalDeviceLimits PhysicalDeviceLimits(
    uint32_t                                    maxImageDimension1D,
    uint32_t                                    maxImageDimension2D,
    uint32_t                                    maxImageDimension3D,
    uint32_t                                    maxImageDimensionCube,
    uint32_t                                    maxImageArrayLayers,
    uint32_t                                    maxTexelBufferElements,
    uint32_t                                    maxUniformBufferRange,
    uint32_t                                    maxStorageBufferRange,
    uint32_t                                    maxPushConstantsSize,
    uint32_t                                    maxMemoryAllocationCount,
    uint32_t                                    maxSamplerAllocationCount,
    VkDeviceSize                                bufferImageGranularity,
    VkDeviceSize                                sparseAddressSpaceSize,
    uint32_t                                    maxBoundDescriptorSets,
    uint32_t                                    maxPerStageDescriptorSamplers,
    uint32_t                                    maxPerStageDescriptorUniformBuffers,
    uint32_t                                    maxPerStageDescriptorStorageBuffers,
    uint32_t                                    maxPerStageDescriptorSampledImages,
    uint32_t                                    maxPerStageDescriptorStorageImages,
    uint32_t                                    maxPerStageDescriptorInputAttachments,
    uint32_t                                    maxPerStageResources,
    uint32_t                                    maxDescriptorSetSamplers,
    uint32_t                                    maxDescriptorSetUniformBuffers,
    uint32_t                                    maxDescriptorSetUniformBuffersDynamic,
    uint32_t                                    maxDescriptorSetStorageBuffers,
    uint32_t                                    maxDescriptorSetStorageBuffersDynamic,
    uint32_t                                    maxDescriptorSetSampledImages,
    uint32_t                                    maxDescriptorSetStorageImages,
    uint32_t                                    maxDescriptorSetInputAttachments,
    uint32_t                                    maxVertexInputAttributes,
    uint32_t                                    maxVertexInputBindings,
    uint32_t                                    maxVertexInputAttributeOffset,
    uint32_t                                    maxVertexInputBindingStride,
    uint32_t                                    maxVertexOutputComponents,
    uint32_t                                    maxTessellationGenerationLevel,
    uint32_t                                    maxTessellationPatchSize,
    uint32_t                                    maxTessellationControlPerVertexInputComponents,
    uint32_t                                    maxTessellationControlPerVertexOutputComponents,
    uint32_t                                    maxTessellationControlPerPatchOutputComponents,
    uint32_t                                    maxTessellationControlTotalOutputComponents,
    uint32_t                                    maxTessellationEvaluationInputComponents,
    uint32_t                                    maxTessellationEvaluationOutputComponents,
    uint32_t                                    maxGeometryShaderInvocations,
    uint32_t                                    maxGeometryInputComponents,
    uint32_t                                    maxGeometryOutputComponents,
    uint32_t                                    maxGeometryOutputVertices,
    uint32_t                                    maxGeometryTotalOutputComponents,
    uint32_t                                    maxFragmentInputComponents,
    uint32_t                                    maxFragmentOutputAttachments,
    uint32_t                                    maxFragmentDualSrcAttachments,
    uint32_t                                    maxFragmentCombinedOutputResources,
    uint32_t                                    maxComputeSharedMemorySize,
    uint32_t                                    maxComputeWorkGroupCount[3],
    uint32_t                                    maxComputeWorkGroupInvocations,
    uint32_t                                    maxComputeWorkGroupSize[3],
    uint32_t                                    subPixelPrecisionBits,
    uint32_t                                    subTexelPrecisionBits,
    uint32_t                                    mipmapPrecisionBits,
    uint32_t                                    maxDrawIndexedIndexValue,
    uint32_t                                    maxDrawIndirectCount,
    float                                       maxSamplerLodBias,
    float                                       maxSamplerAnisotropy,
    uint32_t                                    maxViewports,
    uint32_t                                    maxViewportDimensions[2],
    float                                       viewportBoundsRange[2],
    uint32_t                                    viewportSubPixelBits,
    size_t                                      minMemoryMapAlignment,
    VkDeviceSize                                minTexelBufferOffsetAlignment,
    VkDeviceSize                                minUniformBufferOffsetAlignment,
    VkDeviceSize                                minStorageBufferOffsetAlignment,
    int32_t                                     minTexelOffset,
    uint32_t                                    maxTexelOffset,
    int32_t                                     minTexelGatherOffset,
    uint32_t                                    maxTexelGatherOffset,
    float                                       minInterpolationOffset,
    float                                       maxInterpolationOffset,
    uint32_t                                    subPixelInterpolationOffsetBits,
    uint32_t                                    maxFramebufferWidth,
    uint32_t                                    maxFramebufferHeight,
    uint32_t                                    maxFramebufferLayers,
    VkSampleCountFlags                          framebufferColorSampleCounts,
    VkSampleCountFlags                          framebufferDepthSampleCounts,
    VkSampleCountFlags                          framebufferStencilSampleCounts,
    VkSampleCountFlags                          framebufferNoAttachmentsSampleCounts,
    uint32_t                                    maxColorAttachments,
    VkSampleCountFlags                          sampledImageColorSampleCounts,
    VkSampleCountFlags                          sampledImageIntegerSampleCounts,
    VkSampleCountFlags                          sampledImageDepthSampleCounts,
    VkSampleCountFlags                          sampledImageStencilSampleCounts,
    VkSampleCountFlags                          storageImageSampleCounts,
    uint32_t                                    maxSampleMaskWords,
    VkBool32                                    timestampComputeAndGraphics,
    float                                       timestampPeriod,
    uint32_t                                    maxClipDistances,
    uint32_t                                    maxCullDistances,
    uint32_t                                    maxCombinedClipAndCullDistances,
    uint32_t                                    discreteQueuePriorities,
    float                                       pointSizeRange[2],
    float                                       lineWidthRange[2],
    float                                       pointSizeGranularity,
    float                                       lineWidthGranularity,
    VkBool32                                    strictLines,
    VkBool32                                    standardSampleLocations,
    VkDeviceSize                                optimalBufferCopyOffsetAlignment,
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment,
    VkDeviceSize                                nonCoherentAtomSize);


VkPhysicalDeviceSparseProperties PhysicalDeviceSparseProperties(
    VkBool32                                    residencyStandard2DBlockShape,
    VkBool32                                    residencyStandard2DMultisampleBlockShape,
    VkBool32                                    residencyStandard3DBlockShape,
    VkBool32                                    residencyAlignedMipSize,
    VkBool32                                    residencyNonResidentStrict);


VkPhysicalDeviceProperties PhysicalDeviceProperties(
    uint32_t                                    apiVersion,
    uint32_t                                    driverVersion,
    uint32_t                                    vendorID,
    uint32_t                                    deviceID,
    VkPhysicalDeviceType                        deviceType,
    char                                        deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    uint8_t                                     pipelineCacheUUID[VK_UUID_SIZE],
    VkPhysicalDeviceLimits                      limits,
    VkPhysicalDeviceSparseProperties            sparseProperties);


VkPhysicalDeviceProperties getPhysicalDeviceProperties(
        VkPhysicalDevice physicalDevice);

VkQueueFamilyProperties QueueFamilyProperties(
    VkQueueFlags                                queueFlags,
    uint32_t                                    queueCount,
    uint32_t                                    timestampValidBits,
    VkExtent3D                                  minImageTransferGranularity);


std::vector< VkQueueFamilyProperties > getPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice physicalDevice);

VkMemoryType MemoryType(
    VkMemoryPropertyFlags                       propertyFlags,
    uint32_t                                    heapIndex);


VkMemoryHeap MemoryHeap(
    VkDeviceSize                                size,
    VkMemoryHeapFlags                           flags);


VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties(
    uint32_t                                    memoryTypeCount,
    VkMemoryType                                memoryTypes[VK_MAX_MEMORY_TYPES],
    uint32_t                                    memoryHeapCount,
    VkMemoryHeap                                memoryHeaps[VK_MAX_MEMORY_HEAPS]);


VkPhysicalDeviceMemoryProperties getPhysicalDeviceMemoryProperties(
        VkPhysicalDevice physicalDevice);

std::shared_ptr<VkDeviceQueueCreateInfoRAII> DeviceQueueCreateInfo(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    float* pQueuePriorities_in_array1, int pQueuePriorities_dim1);


std::shared_ptr<VkDeviceCreateInfoRAII> DeviceCreateInfo(
    VkDeviceCreateFlags                         flags,
    const std::vector<VkDeviceQueueCreateInfo> &vecQueueCreateInfos,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames,
    const VkPhysicalDeviceFeatures *            pEnabledFeatures);


std::shared_ptr<VkDevice_T> createDevice(
        VkPhysicalDevice physicalDevice,
        const VkDeviceCreateInfo & pCreateInfo);

VkExtensionProperties ExtensionProperties(
    char                                        extensionName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion);


std::vector< VkExtensionProperties > enumerateInstanceExtensionProperties(
        const char* pLayerName);

std::vector< VkExtensionProperties > enumerateDeviceExtensionProperties(
        VkPhysicalDevice physicalDevice,
        const char* pLayerName);

VkLayerProperties LayerProperties(
    char                                        layerName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion,
    uint32_t                                    implementationVersion,
    char                                        description[VK_MAX_DESCRIPTION_SIZE]);


std::vector< VkLayerProperties > enumerateInstanceLayerProperties(void);

std::vector< VkLayerProperties > enumerateDeviceLayerProperties(
        VkPhysicalDevice physicalDevice);

VkQueue getDeviceQueue(
        VkDevice device,
        uint32_t queueFamilyIndex,
        uint32_t queueIndex);

std::shared_ptr<VkSubmitInfoRAII> SubmitInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkPipelineStageFlags> &   vecWaitDstStageMask,
    const std::vector<VkCommandBuffer> &        vecCommandBuffers,
    const std::vector<VkSemaphore> &            vecSignalSemaphores);


void  queueSubmit(
        VkQueue queue,
        const std::vector<VkSubmitInfo> & pSubmits,
        VkFence fence);

void  queueWaitIdle(
        VkQueue queue);

void  deviceWaitIdle(
        VkDevice device);

VkMemoryAllocateInfo MemoryAllocateInfo(
    VkDeviceSize                                allocationSize,
    uint32_t                                    memoryTypeIndex);


std::shared_ptr<VkDeviceMemory_T> allocateMemory(
        VkDevice device,
        const VkMemoryAllocateInfo & pAllocateInfo);

void  unmapMemory(
        VkDevice device,
        VkDeviceMemory memory);

VkMappedMemoryRange MappedMemoryRange(
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size);


void  flushMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges);

void  invalidateMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges);

VkDeviceSize getDeviceMemoryCommitment(
        VkDevice device,
        VkDeviceMemory memory);

void  bindBufferMemory(
        VkDevice device,
        VkBuffer buffer,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset);

void  bindImageMemory(
        VkDevice device,
        VkImage image,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset);

VkMemoryRequirements MemoryRequirements(
    VkDeviceSize                                size,
    VkDeviceSize                                alignment,
    uint32_t                                    memoryTypeBits);


VkMemoryRequirements getBufferMemoryRequirements(
        VkDevice device,
        VkBuffer buffer);

VkMemoryRequirements getImageMemoryRequirements(
        VkDevice device,
        VkImage image);

VkSparseImageFormatProperties SparseImageFormatProperties(
    VkImageAspectFlags                          aspectMask,
    VkExtent3D                                  imageGranularity,
    VkSparseImageFormatFlags                    flags);


VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
    VkSparseImageFormatProperties               formatProperties,
    uint32_t                                    imageMipTailFirstLod,
    VkDeviceSize                                imageMipTailSize,
    VkDeviceSize                                imageMipTailOffset,
    VkDeviceSize                                imageMipTailStride);


std::vector< VkSparseImageMemoryRequirements > getImageSparseMemoryRequirements(
        VkDevice device,
        VkImage image);

std::vector< VkSparseImageFormatProperties > getPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkSampleCountFlagBits samples,
        VkImageUsageFlags usage,
        VkImageTiling tiling);

VkSparseMemoryBind SparseMemoryBind(
    VkDeviceSize                                resourceOffset,
    VkDeviceSize                                size,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags);


std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> SparseBufferMemoryBindInfo(
    VkBuffer                                    buffer,
    const std::vector<VkSparseMemoryBind> &     vecBinds);


std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> SparseImageOpaqueMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseMemoryBind> &     vecBinds);


VkImageSubresource ImageSubresource(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    arrayLayer);


VkOffset3D Offset3D(
    int32_t                                     x,
    int32_t                                     y,
    int32_t                                     z);


VkSparseImageMemoryBind SparseImageMemoryBind(
    VkImageSubresource                          subresource,
    VkOffset3D                                  offset,
    VkExtent3D                                  extent,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags);


std::shared_ptr<VkSparseImageMemoryBindInfoRAII> SparseImageMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseImageMemoryBind> &vecBinds);


std::shared_ptr<VkBindSparseInfoRAII> BindSparseInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSparseBufferMemoryBindInfo> &vecBufferBinds,
    const std::vector<VkSparseImageOpaqueMemoryBindInfo> &vecImageOpaqueBinds,
    const std::vector<VkSparseImageMemoryBindInfo> &vecImageBinds,
    const std::vector<VkSemaphore> &            vecSignalSemaphores);


void  queueBindSparse(
        VkQueue queue,
        const std::vector<VkBindSparseInfo> & pBindInfo,
        VkFence fence);

VkFenceCreateInfo FenceCreateInfo(
    VkFenceCreateFlags                          flags);


std::shared_ptr<VkFence_T> createFence(
        VkDevice device,
        const VkFenceCreateInfo & pCreateInfo);

void  resetFences(
        VkDevice device,
        const std::vector<VkFence> & pFences);

void  getFenceStatus(
        VkDevice device,
        VkFence fence);

void  waitForFences(
        VkDevice device,
        const std::vector<VkFence> & pFences,
        VkBool32 waitAll,
        uint64_t timeout);

VkSemaphoreCreateInfo SemaphoreCreateInfo(
    VkSemaphoreCreateFlags                      flags);


std::shared_ptr<VkSemaphore_T> createSemaphore(
        VkDevice device,
        const VkSemaphoreCreateInfo & pCreateInfo);

VkEventCreateInfo EventCreateInfo(
    VkEventCreateFlags                          flags);


std::shared_ptr<VkEvent_T> createEvent(
        VkDevice device,
        const VkEventCreateInfo & pCreateInfo);

void  getEventStatus(
        VkDevice device,
        VkEvent event);

void  setEvent(
        VkDevice device,
        VkEvent event);

void  resetEvent(
        VkDevice device,
        VkEvent event);

VkQueryPoolCreateInfo QueryPoolCreateInfo(
    VkQueryPoolCreateFlags                      flags,
    VkQueryType                                 queryType,
    uint32_t                                    queryCount,
    VkQueryPipelineStatisticFlags               pipelineStatistics);


std::shared_ptr<VkQueryPool_T> createQueryPool(
        VkDevice device,
        const VkQueryPoolCreateInfo & pCreateInfo);

void  getQueryPoolResults(
        VkDevice device,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        size_t dataSize,
        VkDeviceSize stride,
        VkQueryResultFlags flags);

std::shared_ptr<VkBufferCreateInfoRAII> BufferCreateInfo(
    VkBufferCreateFlags                         flags,
    VkDeviceSize                                size,
    VkBufferUsageFlags                          usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1);


std::shared_ptr<VkBuffer_T> createBuffer(
        VkDevice device,
        const VkBufferCreateInfo & pCreateInfo);

VkBufferViewCreateInfo BufferViewCreateInfo(
    VkBufferViewCreateFlags                     flags,
    VkBuffer                                    buffer,
    VkFormat                                    format,
    VkDeviceSize                                offset,
    VkDeviceSize                                range);


std::shared_ptr<VkBufferView_T> createBufferView(
        VkDevice device,
        const VkBufferViewCreateInfo & pCreateInfo);

std::shared_ptr<VkImageCreateInfoRAII> ImageCreateInfo(
    VkImageCreateFlags                          flags,
    VkImageType                                 imageType,
    VkFormat                                    format,
    VkExtent3D                                  extent,
    uint32_t                                    mipLevels,
    uint32_t                                    arrayLayers,
    VkSampleCountFlagBits                       samples,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkImageLayout                               initialLayout);


std::shared_ptr<VkImage_T> createImage(
        VkDevice device,
        const VkImageCreateInfo & pCreateInfo);

VkSubresourceLayout SubresourceLayout(
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkDeviceSize                                rowPitch,
    VkDeviceSize                                arrayPitch,
    VkDeviceSize                                depthPitch);


VkSubresourceLayout getImageSubresourceLayout(
        VkDevice device,
        VkImage image,
        const VkImageSubresource & pSubresource);

VkComponentMapping ComponentMapping(
    VkComponentSwizzle                          r,
    VkComponentSwizzle                          g,
    VkComponentSwizzle                          b,
    VkComponentSwizzle                          a);


VkImageSubresourceRange ImageSubresourceRange(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    baseMipLevel,
    uint32_t                                    levelCount,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


VkImageViewCreateInfo ImageViewCreateInfo(
    VkImageViewCreateFlags                      flags,
    VkImage                                     image,
    VkImageViewType                             viewType,
    VkFormat                                    format,
    VkComponentMapping                          components,
    VkImageSubresourceRange                     subresourceRange);


std::shared_ptr<VkImageView_T> createImageView(
        VkDevice device,
        const VkImageViewCreateInfo & pCreateInfo);

VkShaderModuleCreateInfo ShaderModuleCreateInfo(
    VkShaderModuleCreateFlags                   flags,
    size_t                                      codeSize,
    const uint32_t*                             pCode);


std::shared_ptr<VkShaderModule_T> createShaderModule(
        VkDevice device,
        const VkShaderModuleCreateInfo & pCreateInfo);

VkPipelineCacheCreateInfo PipelineCacheCreateInfo(
    VkPipelineCacheCreateFlags                  flags,
    size_t                                      initialDataSize);


std::shared_ptr<VkPipelineCache_T> createPipelineCache(
        VkDevice device,
        const VkPipelineCacheCreateInfo & pCreateInfo);

size_t getPipelineCacheData(
        VkDevice device,
        VkPipelineCache pipelineCache);

void  mergePipelineCaches(
        VkDevice device,
        VkPipelineCache dstCache,
        const std::vector<VkPipelineCache> & pSrcCaches);

VkSpecializationMapEntry SpecializationMapEntry(
    uint32_t                                    constantID,
    uint32_t                                    offset,
    size_t                                      size);


std::shared_ptr<VkSpecializationInfoRAII> SpecializationInfo(
    const std::vector<VkSpecializationMapEntry> &vecMapEntries,
    size_t                                      dataSize);


std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> PipelineShaderStageCreateInfo(
    VkPipelineShaderStageCreateFlags            flags,
    VkShaderStageFlagBits                       stage,
    VkShaderModule                              module,
    const std::string &                         strName,
    const std::shared_ptr<VkSpecializationInfoRAII> &pSpecializationInfo);


VkVertexInputBindingDescription VertexInputBindingDescription(
    uint32_t                                    binding,
    uint32_t                                    stride,
    VkVertexInputRate                           inputRate);


VkVertexInputAttributeDescription VertexInputAttributeDescription(
    uint32_t                                    location,
    uint32_t                                    binding,
    VkFormat                                    format,
    uint32_t                                    offset);


std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> PipelineVertexInputStateCreateInfo(
    VkPipelineVertexInputStateCreateFlags       flags,
    const std::vector<VkVertexInputBindingDescription> &vecVertexBindingDescriptions,
    const std::vector<VkVertexInputAttributeDescription> &vecVertexAttributeDescriptions);


VkPipelineInputAssemblyStateCreateInfo PipelineInputAssemblyStateCreateInfo(
    VkPipelineInputAssemblyStateCreateFlags     flags,
    VkPrimitiveTopology                         topology,
    VkBool32                                    primitiveRestartEnable);


VkPipelineTessellationStateCreateInfo PipelineTessellationStateCreateInfo(
    VkPipelineTessellationStateCreateFlags      flags,
    uint32_t                                    patchControlPoints);


VkViewport Viewport(
    float                                       x,
    float                                       y,
    float                                       width,
    float                                       height,
    float                                       minDepth,
    float                                       maxDepth);


VkOffset2D Offset2D(
    int32_t                                     x,
    int32_t                                     y);


VkExtent2D Extent2D(
    uint32_t                                    width,
    uint32_t                                    height);


VkRect2D Rect2D(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent);


std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> PipelineViewportStateCreateInfo(
    VkPipelineViewportStateCreateFlags          flags,
    const std::vector<VkViewport> &             vecViewports,
    const std::vector<VkRect2D> &               vecScissors);


VkPipelineRasterizationStateCreateInfo PipelineRasterizationStateCreateInfo(
    VkPipelineRasterizationStateCreateFlags     flags,
    VkBool32                                    depthClampEnable,
    VkBool32                                    rasterizerDiscardEnable,
    VkPolygonMode                               polygonMode,
    VkCullModeFlags                             cullMode,
    VkFrontFace                                 frontFace,
    VkBool32                                    depthBiasEnable,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor,
    float                                       lineWidth);


VkPipelineMultisampleStateCreateInfo PipelineMultisampleStateCreateInfo(
    VkPipelineMultisampleStateCreateFlags       flags,
    VkSampleCountFlagBits                       rasterizationSamples,
    VkBool32                                    sampleShadingEnable,
    float                                       minSampleShading,
    const VkSampleMask*                         pSampleMask,
    VkBool32                                    alphaToCoverageEnable,
    VkBool32                                    alphaToOneEnable);


VkStencilOpState StencilOpState(
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp,
    uint32_t                                    compareMask,
    uint32_t                                    writeMask,
    uint32_t                                    reference);


VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilStateCreateInfo(
    VkPipelineDepthStencilStateCreateFlags      flags,
    VkBool32                                    depthTestEnable,
    VkBool32                                    depthWriteEnable,
    VkCompareOp                                 depthCompareOp,
    VkBool32                                    depthBoundsTestEnable,
    VkBool32                                    stencilTestEnable,
    VkStencilOpState                            front,
    VkStencilOpState                            back,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);


VkPipelineColorBlendAttachmentState PipelineColorBlendAttachmentState(
    VkBool32                                    blendEnable,
    VkBlendFactor                               srcColorBlendFactor,
    VkBlendFactor                               dstColorBlendFactor,
    VkBlendOp                                   colorBlendOp,
    VkBlendFactor                               srcAlphaBlendFactor,
    VkBlendFactor                               dstAlphaBlendFactor,
    VkBlendOp                                   alphaBlendOp,
    VkColorComponentFlags                       colorWriteMask);


std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> PipelineColorBlendStateCreateInfo(
    VkPipelineColorBlendStateCreateFlags        flags,
    VkBool32                                    logicOpEnable,
    VkLogicOp                                   logicOp,
    const std::vector<VkPipelineColorBlendAttachmentState> &vecAttachments,
    float                                       blendConstants[4]);


std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> PipelineDynamicStateCreateInfo(
    VkPipelineDynamicStateCreateFlags           flags,
    const std::vector<VkDynamicState> &         vecDynamicStates);


std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> GraphicsPipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    const std::vector<VkPipelineShaderStageCreateInfo> &vecStages,
    const std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> &pVertexInputState,
    const VkPipelineInputAssemblyStateCreateInfo *pInputAssemblyState,
    const VkPipelineTessellationStateCreateInfo *pTessellationState,
    const std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> &pViewportState,
    const VkPipelineRasterizationStateCreateInfo *pRasterizationState,
    const VkPipelineMultisampleStateCreateInfo *pMultisampleState,
    const VkPipelineDepthStencilStateCreateInfo *pDepthStencilState,
    const std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> &pColorBlendState,
    const std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> &pDynamicState,
    VkPipelineLayout                            layout,
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex);


std::vector< std::shared_ptr<VkPipeline_T> > createGraphicsPipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkGraphicsPipelineCreateInfo> & pCreateInfos);

VkComputePipelineCreateInfo ComputePipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    VkPipelineShaderStageCreateInfo             stage,
    VkPipelineLayout                            layout,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex);


std::vector< std::shared_ptr<VkPipeline_T> > createComputePipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkComputePipelineCreateInfo> & pCreateInfos);

VkPushConstantRange PushConstantRange(
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size);


std::shared_ptr<VkPipelineLayoutCreateInfoRAII> PipelineLayoutCreateInfo(
    VkPipelineLayoutCreateFlags                 flags,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts,
    const std::vector<VkPushConstantRange> &    vecPushConstantRanges);


std::shared_ptr<VkPipelineLayout_T> createPipelineLayout(
        VkDevice device,
        const VkPipelineLayoutCreateInfo & pCreateInfo);

VkSamplerCreateInfo SamplerCreateInfo(
    VkSamplerCreateFlags                        flags,
    VkFilter                                    magFilter,
    VkFilter                                    minFilter,
    VkSamplerMipmapMode                         mipmapMode,
    VkSamplerAddressMode                        addressModeU,
    VkSamplerAddressMode                        addressModeV,
    VkSamplerAddressMode                        addressModeW,
    float                                       mipLodBias,
    VkBool32                                    anisotropyEnable,
    float                                       maxAnisotropy,
    VkBool32                                    compareEnable,
    VkCompareOp                                 compareOp,
    float                                       minLod,
    float                                       maxLod,
    VkBorderColor                               borderColor,
    VkBool32                                    unnormalizedCoordinates);


std::shared_ptr<VkSampler_T> createSampler(
        VkDevice device,
        const VkSamplerCreateInfo & pCreateInfo);

std::shared_ptr<VkDescriptorSetLayoutBindingRAII> DescriptorSetLayoutBinding(
    uint32_t                                    binding,
    VkDescriptorType                            descriptorType,
    uint32_t                                    descriptorCount,
    VkShaderStageFlags                          stageFlags,
    const std::vector<VkSampler> &              vecImmutableSamplers);


std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> DescriptorSetLayoutCreateInfo(
    VkDescriptorSetLayoutCreateFlags            flags,
    const std::vector<VkDescriptorSetLayoutBinding> &vecBindings);


std::shared_ptr<VkDescriptorSetLayout_T> createDescriptorSetLayout(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo);

VkDescriptorPoolSize DescriptorPoolSize(
    VkDescriptorType                            type,
    uint32_t                                    descriptorCount);


std::shared_ptr<VkDescriptorPoolCreateInfoRAII> DescriptorPoolCreateInfo(
    VkDescriptorPoolCreateFlags                 flags,
    uint32_t                                    maxSets,
    const std::vector<VkDescriptorPoolSize> &   vecPoolSizes);


std::shared_ptr<VkDescriptorPool_T> createDescriptorPool(
        VkDevice device,
        const VkDescriptorPoolCreateInfo & pCreateInfo);

void  resetDescriptorPool(
        VkDevice device,
        VkDescriptorPool descriptorPool,
        VkDescriptorPoolResetFlags flags);

std::shared_ptr<VkDescriptorSetAllocateInfoRAII> DescriptorSetAllocateInfo(
    VkDescriptorPool                            descriptorPool,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts);


VkDescriptorImageInfo DescriptorImageInfo(
    VkSampler                                   sampler,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout);


VkDescriptorBufferInfo DescriptorBufferInfo(
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                range);


std::shared_ptr<VkWriteDescriptorSetRAII> WriteDescriptorSet(
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    const std::vector<VkDescriptorImageInfo> &  vecImageInfo,
    const std::vector<VkDescriptorBufferInfo> & vecBufferInfo,
    const std::vector<VkBufferView> &           vecTexelBufferView);


VkCopyDescriptorSet CopyDescriptorSet(
    VkDescriptorSet                             srcSet,
    uint32_t                                    srcBinding,
    uint32_t                                    srcArrayElement,
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount);


void  updateDescriptorSets(
        VkDevice device,
        const std::vector<VkWriteDescriptorSet> & pDescriptorWrites,
        const std::vector<VkCopyDescriptorSet> & pDescriptorCopies);

std::shared_ptr<VkFramebufferCreateInfoRAII> FramebufferCreateInfo(
    VkFramebufferCreateFlags                    flags,
    VkRenderPass                                renderPass,
    const std::vector<VkImageView> &            vecAttachments,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    layers);


std::shared_ptr<VkFramebuffer_T> createFramebuffer(
        VkDevice device,
        const VkFramebufferCreateInfo & pCreateInfo);

VkAttachmentDescription AttachmentDescription(
    VkAttachmentDescriptionFlags                flags,
    VkFormat                                    format,
    VkSampleCountFlagBits                       samples,
    VkAttachmentLoadOp                          loadOp,
    VkAttachmentStoreOp                         storeOp,
    VkAttachmentLoadOp                          stencilLoadOp,
    VkAttachmentStoreOp                         stencilStoreOp,
    VkImageLayout                               initialLayout,
    VkImageLayout                               finalLayout);


VkAttachmentReference AttachmentReference(
    uint32_t                                    attachment,
    VkImageLayout                               layout);


std::shared_ptr<VkSubpassDescriptionRAII> SubpassDescription(
    VkSubpassDescriptionFlags                   flags,
    VkPipelineBindPoint                         pipelineBindPoint,
    const std::vector<VkAttachmentReference> &  vecInputAttachments,
    const std::vector<VkAttachmentReference> &  vecColorAttachments,
    const std::vector<VkAttachmentReference> &  vecResolveAttachments,
    const VkAttachmentReference *               pDepthStencilAttachment,
    unsigned int* pPreserveAttachments_in_array1, int pPreserveAttachments_dim1);


VkSubpassDependency SubpassDependency(
    uint32_t                                    srcSubpass,
    uint32_t                                    dstSubpass,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkDependencyFlags                           dependencyFlags);


std::shared_ptr<VkRenderPassCreateInfoRAII> RenderPassCreateInfo(
    VkRenderPassCreateFlags                     flags,
    const std::vector<VkAttachmentDescription> &vecAttachments,
    const std::vector<VkSubpassDescription> &   vecSubpasses,
    const std::vector<VkSubpassDependency> &    vecDependencies);


std::shared_ptr<VkRenderPass_T> createRenderPass(
        VkDevice device,
        const VkRenderPassCreateInfo & pCreateInfo);

VkExtent2D getRenderAreaGranularity(
        VkDevice device,
        VkRenderPass renderPass);

VkCommandPoolCreateInfo CommandPoolCreateInfo(
    VkCommandPoolCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex);


std::shared_ptr<VkCommandPool_T> createCommandPool(
        VkDevice device,
        const VkCommandPoolCreateInfo & pCreateInfo);

void  resetCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolResetFlags flags);

VkCommandBufferAllocateInfo CommandBufferAllocateInfo(
    VkCommandPool                               commandPool,
    VkCommandBufferLevel                        level,
    uint32_t                                    commandBufferCount);


VkCommandBufferInheritanceInfo CommandBufferInheritanceInfo(
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkFramebuffer                               framebuffer,
    VkBool32                                    occlusionQueryEnable,
    VkQueryControlFlags                         queryFlags,
    VkQueryPipelineStatisticFlags               pipelineStatistics);


std::shared_ptr<VkCommandBufferBeginInfoRAII> CommandBufferBeginInfo(
    VkCommandBufferUsageFlags                   flags,
    const VkCommandBufferInheritanceInfo *      pInheritanceInfo);


void  beginCommandBuffer(
        VkCommandBuffer commandBuffer,
        const VkCommandBufferBeginInfo & pBeginInfo);

void  endCommandBuffer(
        VkCommandBuffer commandBuffer);

void  resetCommandBuffer(
        VkCommandBuffer commandBuffer,
        VkCommandBufferResetFlags flags);

void  cmdBindPipeline(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipeline pipeline);

void  cmdSetViewport(
        VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        const std::vector<VkViewport> & pViewports);

void  cmdSetScissor(
        VkCommandBuffer commandBuffer,
        uint32_t firstScissor,
        const std::vector<VkRect2D> & pScissors);

void  cmdSetLineWidth(
        VkCommandBuffer commandBuffer,
        float lineWidth);

void  cmdSetDepthBias(
        VkCommandBuffer commandBuffer,
        float depthBiasConstantFactor,
        float depthBiasClamp,
        float depthBiasSlopeFactor);

void  cmdSetBlendConstants(
        VkCommandBuffer commandBuffer,
        const float blendConstants[4]);

void  cmdSetDepthBounds(
        VkCommandBuffer commandBuffer,
        float minDepthBounds,
        float maxDepthBounds);

void  cmdSetStencilCompareMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t compareMask);

void  cmdSetStencilWriteMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t writeMask);

void  cmdSetStencilReference(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t reference);

void  cmdBindDescriptorSets(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t firstSet,
        const std::vector<VkDescriptorSet> & pDescriptorSets,
        unsigned int* pDynamicOffsets_in_array1, int pDynamicOffsets_dim1);

void  cmdBindIndexBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkIndexType indexType);

void  cmdBindVertexBuffers(
        VkCommandBuffer commandBuffer,
        uint32_t firstBinding,
        const std::vector<VkBuffer> & pBuffers,
        const std::vector<VkDeviceSize> & pOffsets);

void  cmdDraw(
        VkCommandBuffer commandBuffer,
        uint32_t vertexCount,
        uint32_t instanceCount,
        uint32_t firstVertex,
        uint32_t firstInstance);

void  cmdDrawIndexed(
        VkCommandBuffer commandBuffer,
        uint32_t indexCount,
        uint32_t instanceCount,
        uint32_t firstIndex,
        int32_t vertexOffset,
        uint32_t firstInstance);

void  cmdDrawIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride);

void  cmdDrawIndexedIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride);

void  cmdDispatch(
        VkCommandBuffer commandBuffer,
        uint32_t x,
        uint32_t y,
        uint32_t z);

void  cmdDispatchIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset);

VkBufferCopy BufferCopy(
    VkDeviceSize                                srcOffset,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size);


void  cmdCopyBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkBuffer dstBuffer,
        const std::vector<VkBufferCopy> & pRegions);

VkImageSubresourceLayers ImageSubresourceLayers(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


VkImageCopy ImageCopy(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent);


void  cmdCopyImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageCopy> & pRegions);

VkImageBlit ImageBlit(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffsets[2],
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffsets[2]);


void  cmdBlitImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageBlit> & pRegions,
        VkFilter filter);

VkBufferImageCopy BufferImageCopy(
    VkDeviceSize                                bufferOffset,
    uint32_t                                    bufferRowLength,
    uint32_t                                    bufferImageHeight,
    VkImageSubresourceLayers                    imageSubresource,
    VkOffset3D                                  imageOffset,
    VkExtent3D                                  imageExtent);


void  cmdCopyBufferToImage(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkBufferImageCopy> & pRegions);

void  cmdCopyImageToBuffer(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkBuffer dstBuffer,
        const std::vector<VkBufferImageCopy> & pRegions);

void  cmdUpdateBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        const std::vector<unsigned char> & pData);

void  cmdFillBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize size,
        uint32_t data);

void  cmdClearColorImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearColorValue & pColor,
        const std::vector<VkImageSubresourceRange> & pRanges);

VkClearDepthStencilValue ClearDepthStencilValue(
    float                                       depth,
    uint32_t                                    stencil);


void  cmdClearDepthStencilImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearDepthStencilValue & pDepthStencil,
        const std::vector<VkImageSubresourceRange> & pRanges);

VkClearAttachment ClearAttachment(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    colorAttachment,
    VkClearValue                                clearValue);


VkClearRect ClearRect(
    VkRect2D                                    rect,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


void  cmdClearAttachments(
        VkCommandBuffer commandBuffer,
        const std::vector<VkClearAttachment> & pAttachments,
        const std::vector<VkClearRect> & pRects);

VkImageResolve ImageResolve(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent);


void  cmdResolveImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageResolve> & pRegions);

void  cmdSetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask);

void  cmdResetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask);

VkMemoryBarrier MemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask);


VkBufferMemoryBarrier BufferMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                size);


VkImageMemoryBarrier ImageMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkImageLayout                               oldLayout,
    VkImageLayout                               newLayout,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkImage                                     image,
    VkImageSubresourceRange                     subresourceRange);


void  cmdWaitEvents(
        VkCommandBuffer commandBuffer,
        const std::vector<VkEvent> & pEvents,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers);

void  cmdPipelineBarrier(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        VkDependencyFlags dependencyFlags,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers);

void  cmdBeginQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query,
        VkQueryControlFlags flags);

void  cmdEndQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query);

void  cmdResetQueryPool(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount);

void  cmdWriteTimestamp(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlagBits pipelineStage,
        VkQueryPool queryPool,
        uint32_t query);

void  cmdCopyQueryPoolResults(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize stride,
        VkQueryResultFlags flags);

void  cmdPushConstants(
        VkCommandBuffer commandBuffer,
        VkPipelineLayout layout,
        VkShaderStageFlags stageFlags,
        uint32_t offset,
        const std::vector<unsigned char> & pValues);

std::shared_ptr<VkRenderPassBeginInfoRAII> RenderPassBeginInfo(
    VkRenderPass                                renderPass,
    VkFramebuffer                               framebuffer,
    VkRect2D                                    renderArea,
    const std::vector<VkClearValue> &           vecClearValues);


void  cmdBeginRenderPass(
        VkCommandBuffer commandBuffer,
        const VkRenderPassBeginInfo & pRenderPassBegin,
        VkSubpassContents contents);

void  cmdNextSubpass(
        VkCommandBuffer commandBuffer,
        VkSubpassContents contents);

void  cmdEndRenderPass(
        VkCommandBuffer commandBuffer);

void  cmdExecuteCommands(
        VkCommandBuffer commandBuffer,
        const std::vector<VkCommandBuffer> & pCommandBuffers);

VkDispatchIndirectCommand DispatchIndirectCommand(
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z);


VkDrawIndexedIndirectCommand DrawIndexedIndirectCommand(
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);


VkDrawIndirectCommand DrawIndirectCommand(
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);



#define VK_KHR_surface 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)

#define VK_KHR_SURFACE_SPEC_VERSION       25
#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"
#define VK_COLORSPACE_SRGB_NONLINEAR_KHR  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR


typedef enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_BEGIN_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_END_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_RANGE_SIZE_KHR = (VK_COLOR_SPACE_SRGB_NONLINEAR_KHR - VK_COLOR_SPACE_SRGB_NONLINEAR_KHR + 1),
    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkColorSpaceKHR;

typedef enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_BEGIN_RANGE_KHR = VK_PRESENT_MODE_IMMEDIATE_KHR,
    VK_PRESENT_MODE_END_RANGE_KHR = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    VK_PRESENT_MODE_RANGE_SIZE_KHR = (VK_PRESENT_MODE_FIFO_RELAXED_KHR - VK_PRESENT_MODE_IMMEDIATE_KHR + 1),
    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkPresentModeKHR;


typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSurfaceTransformFlagBitsKHR;
typedef VkFlags VkSurfaceTransformFlagsKHR;

typedef enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkCompositeAlphaFlagBitsKHR;
typedef VkFlags VkCompositeAlphaFlagsKHR;

typedef struct VkSurfaceCapabilitiesKHR {
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;

typedef struct VkSurfaceFormatKHR {
    VkFormat           format;
    VkColorSpaceKHR    colorSpace;
} VkSurfaceFormatKHR;


typedef void (VKAPI_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);

VkBool32 getPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VkSurfaceKHR surface);

VkSurfaceCapabilitiesKHR SurfaceCapabilitiesKHR(
    uint32_t                                    minImageCount,
    uint32_t                                    maxImageCount,
    VkExtent2D                                  currentExtent,
    VkExtent2D                                  minImageExtent,
    VkExtent2D                                  maxImageExtent,
    uint32_t                                    maxImageArrayLayers,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkSurfaceTransformFlagBitsKHR               currentTransform,
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha,
    VkImageUsageFlags                           supportedUsageFlags);


VkSurfaceCapabilitiesKHR getPhysicalDeviceSurfaceCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);

VkSurfaceFormatKHR SurfaceFormatKHR(
    VkFormat                                    format,
    VkColorSpaceKHR                             colorSpace);


std::vector< VkSurfaceFormatKHR > getPhysicalDeviceSurfaceFormatsKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);

std::vector< VkPresentModeKHR > getPhysicalDeviceSurfacePresentModesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);


#define VK_KHR_swapchain 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)

#define VK_KHR_SWAPCHAIN_SPEC_VERSION     68
#define VK_KHR_SWAPCHAIN_EXTENSION_NAME   "VK_KHR_swapchain"

typedef VkFlags VkSwapchainCreateFlagsKHR;

typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType                  sType;
    const void*                      pNext;
    VkSwapchainCreateFlagsKHR        flags;
    VkSurfaceKHR                     surface;
    uint32_t                         minImageCount;
    VkFormat                         imageFormat;
    VkColorSpaceKHR                  imageColorSpace;
    VkExtent2D                       imageExtent;
    uint32_t                         imageArrayLayers;
    VkImageUsageFlags                imageUsage;
    VkSharingMode                    imageSharingMode;
    uint32_t                         queueFamilyIndexCount;
    const uint32_t*                  pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR    preTransform;
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    VkPresentModeKHR                 presentMode;
    VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;

struct VkSwapchainCreateInfoKHRRAII {
   VkSwapchainCreateInfoKHR nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkPresentInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 waitSemaphoreCount;
    const VkSemaphore*       pWaitSemaphores;
    uint32_t                 swapchainCount;
    const VkSwapchainKHR*    pSwapchains;
    const uint32_t*          pImageIndices;
    VkResult*                pResults;
} VkPresentInfoKHR;

struct VkPresentInfoKHRRAII {
   VkPresentInfoKHR nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSwapchainKHR>                 vecSwapchains;
    std::vector<uint32_t>                       vecImageIndices;
    std::vector<VkResult>                       vecResults;
};


typedef VkResult (VKAPI_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
typedef void (VKAPI_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
typedef VkResult (VKAPI_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, const VkPresentInfoKHR* pPresentInfo);

std::shared_ptr<VkSwapchainCreateInfoKHRRAII> SwapchainCreateInfoKHR(
    VkSwapchainCreateFlagsKHR                   flags,
    VkSurfaceKHR                                surface,
    uint32_t                                    minImageCount,
    VkFormat                                    imageFormat,
    VkColorSpaceKHR                             imageColorSpace,
    VkExtent2D                                  imageExtent,
    uint32_t                                    imageArrayLayers,
    VkImageUsageFlags                           imageUsage,
    VkSharingMode                               imageSharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkSurfaceTransformFlagBitsKHR               preTransform,
    VkCompositeAlphaFlagBitsKHR                 compositeAlpha,
    VkPresentModeKHR                            presentMode,
    VkBool32                                    clipped,
    VkSwapchainKHR                              oldSwapchain);


std::shared_ptr<VkSwapchainKHR_T> createSwapchainKHR(
        VkDevice device,
        const VkSwapchainCreateInfoKHR & pCreateInfo);

std::vector< VkImage > getSwapchainImagesKHR(
        VkDevice device,
        VkSwapchainKHR swapchain);

uint32_t acquireNextImageKHR(
        VkDevice device,
        VkSwapchainKHR swapchain,
        uint64_t timeout,
        VkSemaphore semaphore,
        VkFence fence);

std::shared_ptr<VkPresentInfoKHRRAII> PresentInfoKHR(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSwapchainKHR> &         vecSwapchains,
    unsigned int* pImageIndices_in_array1, int pImageIndices_dim1,
    const std::vector<VkResult> &               vecResults);


void  queuePresentKHR(
        VkQueue queue,
        const VkPresentInfoKHR & pPresentInfo);


#define VK_KHR_display 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)

#define VK_KHR_DISPLAY_SPEC_VERSION       21
#define VK_KHR_DISPLAY_EXTENSION_NAME     "VK_KHR_display"


typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDisplayPlaneAlphaFlagBitsKHR;
typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
typedef VkFlags VkDisplayModeCreateFlagsKHR;
typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;

typedef struct VkDisplayPropertiesKHR {
    VkDisplayKHR                  display;
    const char*                   displayName;
    VkExtent2D                    physicalDimensions;
    VkExtent2D                    physicalResolution;
    VkSurfaceTransformFlagsKHR    supportedTransforms;
    VkBool32                      planeReorderPossible;
    VkBool32                      persistentContent;
} VkDisplayPropertiesKHR;

struct VkDisplayPropertiesKHRRAII {
   VkDisplayPropertiesKHR nonRaiiObj;
    std::string                                 strisplayName;
};

typedef struct VkDisplayModeParametersKHR {
    VkExtent2D    visibleRegion;
    uint32_t      refreshRate;
} VkDisplayModeParametersKHR;

typedef struct VkDisplayModePropertiesKHR {
    VkDisplayModeKHR              displayMode;
    VkDisplayModeParametersKHR    parameters;
} VkDisplayModePropertiesKHR;

typedef struct VkDisplayModeCreateInfoKHR {
    VkStructureType                sType;
    const void*                    pNext;
    VkDisplayModeCreateFlagsKHR    flags;
    VkDisplayModeParametersKHR     parameters;
} VkDisplayModeCreateInfoKHR;

typedef struct VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    VkOffset2D                     minSrcPosition;
    VkOffset2D                     maxSrcPosition;
    VkExtent2D                     minSrcExtent;
    VkExtent2D                     maxSrcExtent;
    VkOffset2D                     minDstPosition;
    VkOffset2D                     maxDstPosition;
    VkExtent2D                     minDstExtent;
    VkExtent2D                     maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;

typedef struct VkDisplayPlanePropertiesKHR {
    VkDisplayKHR    currentDisplay;
    uint32_t        currentStackIndex;
} VkDisplayPlanePropertiesKHR;

typedef struct VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkDisplaySurfaceCreateFlagsKHR    flags;
    VkDisplayModeKHR                  displayMode;
    uint32_t                          planeIndex;
    uint32_t                          planeStackIndex;
    VkSurfaceTransformFlagBitsKHR     transform;
    float                             globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    VkExtent2D                        imageExtent;
} VkDisplaySurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

std::shared_ptr<VkDisplayPropertiesKHRRAII> DisplayPropertiesKHR(
    VkDisplayKHR                                display,
    const std::string &                         strisplayName,
    VkExtent2D                                  physicalDimensions,
    VkExtent2D                                  physicalResolution,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkBool32                                    planeReorderPossible,
    VkBool32                                    persistentContent);


VkDisplayModeParametersKHR DisplayModeParametersKHR(
    VkExtent2D                                  visibleRegion,
    uint32_t                                    refreshRate);


VkDisplayModePropertiesKHR DisplayModePropertiesKHR(
    VkDisplayModeKHR                            displayMode,
    VkDisplayModeParametersKHR                  parameters);


VkDisplayModeCreateInfoKHR DisplayModeCreateInfoKHR(
    VkDisplayModeCreateFlagsKHR                 flags,
    VkDisplayModeParametersKHR                  parameters);


VkDisplayPlaneCapabilitiesKHR DisplayPlaneCapabilitiesKHR(
    VkDisplayPlaneAlphaFlagsKHR                 supportedAlpha,
    VkOffset2D                                  minSrcPosition,
    VkOffset2D                                  maxSrcPosition,
    VkExtent2D                                  minSrcExtent,
    VkExtent2D                                  maxSrcExtent,
    VkOffset2D                                  minDstPosition,
    VkOffset2D                                  maxDstPosition,
    VkExtent2D                                  minDstExtent,
    VkExtent2D                                  maxDstExtent);


VkDisplayPlanePropertiesKHR DisplayPlanePropertiesKHR(
    VkDisplayKHR                                currentDisplay,
    uint32_t                                    currentStackIndex);


VkDisplaySurfaceCreateInfoKHR DisplaySurfaceCreateInfoKHR(
    VkDisplaySurfaceCreateFlagsKHR              flags,
    VkDisplayModeKHR                            displayMode,
    uint32_t                                    planeIndex,
    uint32_t                                    planeStackIndex,
    VkSurfaceTransformFlagBitsKHR               transform,
    float                                       globalAlpha,
    VkDisplayPlaneAlphaFlagBitsKHR              alphaMode,
    VkExtent2D                                  imageExtent);


std::vector< VkDisplayPropertiesKHR > getPhysicalDeviceDisplayPropertiesKHR(
        VkPhysicalDevice physicalDevice);

std::vector< VkDisplayPlanePropertiesKHR > getPhysicalDeviceDisplayPlanePropertiesKHR(
        VkPhysicalDevice physicalDevice);

std::vector< VkDisplayKHR > getDisplayPlaneSupportedDisplaysKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t planeIndex);

std::vector< VkDisplayModePropertiesKHR > getDisplayModePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display);

std::shared_ptr<VkDisplayModeKHR_T> createDisplayModeKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        const VkDisplayModeCreateInfoKHR & pCreateInfo);

VkDisplayPlaneCapabilitiesKHR getDisplayPlaneCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayModeKHR mode,
        uint32_t planeIndex);

std::shared_ptr<VkSurfaceKHR_T> createDisplayPlaneSurfaceKHR(
        VkInstance instance,
        const VkDisplaySurfaceCreateInfoKHR & pCreateInfo);


#define VK_KHR_display_swapchain 1
#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 9
#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

typedef struct VkDisplayPresentInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkRect2D           srcRect;
    VkRect2D           dstRect;
    VkBool32           persistent;
} VkDisplayPresentInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);

VkDisplayPresentInfoKHR DisplayPresentInfoKHR(
    VkRect2D                                    srcRect,
    VkRect2D                                    dstRect,
    VkBool32                                    persistent);


std::vector< std::shared_ptr<VkSwapchainKHR_T> > createSharedSwapchainsKHR(
        VkDevice device,
        const std::vector<VkSwapchainCreateInfoKHR> & pCreateInfos);


#ifdef VK_USE_PLATFORM_XLIB_KHR
#define VK_KHR_xlib_surface 1
#include <X11/Xlib.h>

#define VK_KHR_XLIB_SURFACE_SPEC_VERSION  6
#define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

typedef VkFlags VkXlibSurfaceCreateFlagsKHR;

typedef struct VkXlibSurfaceCreateInfoKHR {
    VkStructureType                sType;
    const void*                    pNext;
    VkXlibSurfaceCreateFlagsKHR    flags;
    Display*                       dpy;
    Window                         window;
} VkXlibSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);

VkXlibSurfaceCreateInfoKHR XlibSurfaceCreateInfoKHR(
    VkXlibSurfaceCreateFlagsKHR                 flags,
    Display*                                    dpy,
    Window                                      window);


std::shared_ptr<VkSurfaceKHR_T> createXlibSurfaceKHR(
        VkInstance instance,
        const VkXlibSurfaceCreateInfoKHR & pCreateInfo);

std::shared_ptr< Display > getPhysicalDeviceXlibPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VisualID visualID);

#endif /* VK_USE_PLATFORM_XLIB_KHR */

#ifdef VK_USE_PLATFORM_XCB_KHR
#define VK_KHR_xcb_surface 1
#include <xcb/xcb.h>

#define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
#define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

typedef VkFlags VkXcbSurfaceCreateFlagsKHR;

typedef struct VkXcbSurfaceCreateInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    VkXcbSurfaceCreateFlagsKHR    flags;
    xcb_connection_t*             connection;
    xcb_window_t                  window;
} VkXcbSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);

VkXcbSurfaceCreateInfoKHR XcbSurfaceCreateInfoKHR(
    VkXcbSurfaceCreateFlagsKHR                  flags,
    xcb_connection_t*                           connection,
    xcb_window_t                                window);


std::shared_ptr<VkSurfaceKHR_T> createXcbSurfaceKHR(
        VkInstance instance,
        const VkXcbSurfaceCreateInfoKHR & pCreateInfo);

std::shared_ptr< xcb_connection_t > getPhysicalDeviceXcbPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        xcb_visualid_t visual_id);

#endif /* VK_USE_PLATFORM_XCB_KHR */

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#define VK_KHR_wayland_surface 1
#include <wayland-client.h>

#define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 5
#define VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "VK_KHR_wayland_surface"

typedef VkFlags VkWaylandSurfaceCreateFlagsKHR;

typedef struct VkWaylandSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkWaylandSurfaceCreateFlagsKHR    flags;
    struct wl_display*                display;
    struct wl_surface*                surface;
} VkWaylandSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWaylandSurfaceKHR)(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display);

VkWaylandSurfaceCreateInfoKHR WaylandSurfaceCreateInfoKHR(
    VkWaylandSurfaceCreateFlagsKHR              flags,
    struct wl_display*                          display,
    struct wl_surface*                          surface);


std::shared_ptr<VkSurfaceKHR_T> createWaylandSurfaceKHR(
        VkInstance instance,
        const VkWaylandSurfaceCreateInfoKHR & pCreateInfo);

std::shared_ptr< wl_display > getPhysicalDeviceWaylandPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex);

#endif /* VK_USE_PLATFORM_WAYLAND_KHR */

#ifdef VK_USE_PLATFORM_MIR_KHR
#define VK_KHR_mir_surface 1
#include <mir_toolkit/client_types.h>

#define VK_KHR_MIR_SURFACE_SPEC_VERSION   4
#define VK_KHR_MIR_SURFACE_EXTENSION_NAME "VK_KHR_mir_surface"

typedef VkFlags VkMirSurfaceCreateFlagsKHR;

typedef struct VkMirSurfaceCreateInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    VkMirSurfaceCreateFlagsKHR    flags;
    MirConnection*                connection;
    MirSurface*                   mirSurface;
} VkMirSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateMirSurfaceKHR)(VkInstance instance, const VkMirSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceMirPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, MirConnection* connection);

VkMirSurfaceCreateInfoKHR MirSurfaceCreateInfoKHR(
    VkMirSurfaceCreateFlagsKHR                  flags,
    MirConnection*                              connection,
    MirSurface*                                 mirSurface);


std::shared_ptr<VkSurfaceKHR_T> createMirSurfaceKHR(
        VkInstance instance,
        const VkMirSurfaceCreateInfoKHR & pCreateInfo);

std::shared_ptr< MirConnection > getPhysicalDeviceMirPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex);

#endif /* VK_USE_PLATFORM_MIR_KHR */

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#define VK_KHR_android_surface 1
#include <android/native_window.h>

#define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
#define VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "VK_KHR_android_surface"

typedef VkFlags VkAndroidSurfaceCreateFlagsKHR;

typedef struct VkAndroidSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkAndroidSurfaceCreateFlagsKHR    flags;
    ANativeWindow*                    window;
} VkAndroidSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateAndroidSurfaceKHR)(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

VkAndroidSurfaceCreateInfoKHR AndroidSurfaceCreateInfoKHR(
    VkAndroidSurfaceCreateFlagsKHR              flags,
    ANativeWindow*                              window);


std::shared_ptr<VkSurfaceKHR_T> createAndroidSurfaceKHR(
        VkInstance instance,
        const VkAndroidSurfaceCreateInfoKHR & pCreateInfo);

#endif /* VK_USE_PLATFORM_ANDROID_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_win32_surface 1
#include <windows.h>

#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 5
#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"

typedef VkFlags VkWin32SurfaceCreateFlagsKHR;

typedef struct VkWin32SurfaceCreateInfoKHR {
    VkStructureType                 sType;
    const void*                     pNext;
    VkWin32SurfaceCreateFlagsKHR    flags;
    HINSTANCE                       hinstance;
    HWND                            hwnd;
} VkWin32SurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);

VkWin32SurfaceCreateInfoKHR Win32SurfaceCreateInfoKHR(
    VkWin32SurfaceCreateFlagsKHR                flags,
    HINSTANCE                                   hinstance,
    HWND                                        hwnd);


std::shared_ptr<VkSurfaceKHR_T> createWin32SurfaceKHR(
        VkInstance instance,
        const VkWin32SurfaceCreateInfoKHR & pCreateInfo);

void  getPhysicalDeviceWin32PresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex);

#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_sampler_mirror_clamp_to_edge 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"


#define VK_EXT_debug_report 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)

#define VK_EXT_DEBUG_REPORT_SPEC_VERSION  3
#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
#define VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT


typedef enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT - VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT + 1),
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportObjectTypeEXT;

typedef enum VkDebugReportErrorEXT {
    VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
    VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
    VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_ERROR_NONE_EXT,
    VK_DEBUG_REPORT_ERROR_END_RANGE_EXT = VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT,
    VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT - VK_DEBUG_REPORT_ERROR_NONE_EXT + 1),
    VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportErrorEXT;


typedef enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportFlagBitsEXT;
typedef VkFlags VkDebugReportFlagsEXT;

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage,
    void*                                       pUserData);


typedef struct VkDebugReportCallbackCreateInfoEXT {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDebugReportFlagsEXT           flags;
    PFN_vkDebugReportCallbackEXT    pfnCallback;
    void*                           pUserData;
} VkDebugReportCallbackCreateInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback);
typedef void (VKAPI_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage);

VkDebugReportCallbackCreateInfoEXT DebugReportCallbackCreateInfoEXT(
    VkDebugReportFlagsEXT                       flags,
    PFN_vkDebugReportCallbackEXT                pfnCallback);


std::shared_ptr<VkDebugReportCallbackEXT_T> createDebugReportCallbackEXT(
        VkInstance instance,
        const VkDebugReportCallbackCreateInfoEXT & pCreateInfo);

void  debugReportMessageEXT(
        VkInstance instance,
        VkDebugReportFlagsEXT flags,
        VkDebugReportObjectTypeEXT objectType,
        uint64_t object,
        size_t location,
        int32_t messageCode,
        const char* pLayerPrefix,
        const char* pMessage);


#define VK_NV_glsl_shader 1
#define VK_NV_GLSL_SHADER_SPEC_VERSION    1
#define VK_NV_GLSL_SHADER_EXTENSION_NAME  "VK_NV_glsl_shader"


#define VK_IMG_filter_cubic 1
#define VK_IMG_FILTER_CUBIC_SPEC_VERSION  1
#define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"


#define VK_AMD_rasterization_order 1
#define VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION 1
#define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"


typedef enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD = VK_RASTERIZATION_ORDER_STRICT_AMD,
    VK_RASTERIZATION_ORDER_END_RANGE_AMD = VK_RASTERIZATION_ORDER_RELAXED_AMD,
    VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = (VK_RASTERIZATION_ORDER_RELAXED_AMD - VK_RASTERIZATION_ORDER_STRICT_AMD + 1),
    VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF
} VkRasterizationOrderAMD;

typedef struct VkPipelineRasterizationStateRasterizationOrderAMD {
    VkStructureType            sType;
    const void*                pNext;
    VkRasterizationOrderAMD    rasterizationOrder;
} VkPipelineRasterizationStateRasterizationOrderAMD;


VkPipelineRasterizationStateRasterizationOrderAMD PipelineRasterizationStateRasterizationOrderAMD(
    VkRasterizationOrderAMD                     rasterizationOrder);



#define VK_AMD_shader_trinary_minmax 1
#define VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION 1
#define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"


#define VK_AMD_shader_explicit_vertex_parameter 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"


#define VK_EXT_debug_marker 1
#define VK_EXT_DEBUG_MARKER_SPEC_VERSION  3
#define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

typedef struct VkDebugMarkerObjectNameInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    const char*                   pObjectName;
} VkDebugMarkerObjectNameInfoEXT;

struct VkDebugMarkerObjectNameInfoEXTRAII {
   VkDebugMarkerObjectNameInfoEXT nonRaiiObj;
    std::string                                 strObjectName;
};

typedef struct VkDebugMarkerObjectTagInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    uint64_t                      tagName;
    size_t                        tagSize;
    const void*                   pTag;
} VkDebugMarkerObjectTagInfoEXT;

typedef struct VkDebugMarkerMarkerInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pMarkerName;
    float              color[4];
} VkDebugMarkerMarkerInfoEXT;

struct VkDebugMarkerMarkerInfoEXTRAII {
   VkDebugMarkerMarkerInfoEXT nonRaiiObj;
    std::string                                 strMarkerName;
};


typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectTagEXT)(VkDevice device, VkDebugMarkerObjectTagInfoEXT* pTagInfo);
typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectNameEXT)(VkDevice device, VkDebugMarkerObjectNameInfoEXT* pNameInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerEndEXT)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);

std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII> DebugMarkerObjectNameInfoEXT(
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    const std::string &                         strObjectName);


VkDebugMarkerObjectTagInfoEXT DebugMarkerObjectTagInfoEXT(
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    uint64_t                                    tagName,
    size_t                                      tagSize);


std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII> DebugMarkerMarkerInfoEXT(
    const std::string &                         strMarkerName,
    float                                       color[4]);


VkDebugMarkerObjectTagInfoEXT debugMarkerSetObjectTagEXT(
        VkDevice device);

std::shared_ptr< VkDebugMarkerObjectNameInfoEXT > debugMarkerSetObjectNameEXT(
        VkDevice device);

std::shared_ptr< VkDebugMarkerMarkerInfoEXT > cmdDebugMarkerBeginEXT(
        VkCommandBuffer commandBuffer);

void  cmdDebugMarkerEndEXT(
        VkCommandBuffer commandBuffer);

std::shared_ptr< VkDebugMarkerMarkerInfoEXT > cmdDebugMarkerInsertEXT(
        VkCommandBuffer commandBuffer);


#define VK_AMD_gcn_shader 1
#define VK_AMD_GCN_SHADER_SPEC_VERSION    1
#define VK_AMD_GCN_SHADER_EXTENSION_NAME  "VK_AMD_gcn_shader"


#define VK_NV_dedicated_allocation 1
#define VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION 1
#define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"

typedef struct VkDedicatedAllocationImageCreateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationImageCreateInfoNV;

typedef struct VkDedicatedAllocationBufferCreateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationBufferCreateInfoNV;

typedef struct VkDedicatedAllocationMemoryAllocateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkDedicatedAllocationMemoryAllocateInfoNV;


VkDedicatedAllocationImageCreateInfoNV DedicatedAllocationImageCreateInfoNV(
    VkBool32                                    dedicatedAllocation);


VkDedicatedAllocationBufferCreateInfoNV DedicatedAllocationBufferCreateInfoNV(
    VkBool32                                    dedicatedAllocation);


VkDedicatedAllocationMemoryAllocateInfoNV DedicatedAllocationMemoryAllocateInfoNV(
    VkImage                                     image,
    VkBuffer                                    buffer);



#define VK_AMD_draw_indirect_count 1
#define VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
#define VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"

typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);

void  cmdDrawIndirectCountAMD(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride);

void  cmdDrawIndexedIndirectCountAMD(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride);


#define VK_AMD_negative_viewport_height 1
#define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION 0
#define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME "VK_AMD_negative_viewport_height"


#define VK_AMD_gpu_shader_half_float 1
#define VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION 1
#define VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME "VK_AMD_gpu_shader_half_float"


#define VK_AMD_shader_ballot 1
#define VK_AMD_SHADER_BALLOT_SPEC_VERSION 0
#define VK_AMD_SHADER_BALLOT_EXTENSION_NAME "VK_AMD_shader_ballot"


#define VK_IMG_format_pvrtc 1
#define VK_IMG_FORMAT_PVRTC_SPEC_VERSION  1
#define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"


#define VK_NV_external_memory_capabilities 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"


typedef enum VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBitsNV;
typedef VkFlags VkExternalMemoryHandleTypeFlagsNV;

typedef enum VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBitsNV;
typedef VkFlags VkExternalMemoryFeatureFlagsNV;

typedef struct VkExternalImageFormatPropertiesNV {
    VkImageFormatProperties              imageFormatProperties;
    VkExternalMemoryFeatureFlagsNV       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlagsNV    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlagsNV    compatibleHandleTypes;
} VkExternalImageFormatPropertiesNV;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties);

VkExternalImageFormatPropertiesNV ExternalImageFormatPropertiesNV(
    VkImageFormatProperties                     imageFormatProperties,
    VkExternalMemoryFeatureFlagsNV              externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlagsNV           exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlagsNV           compatibleHandleTypes);


VkExternalImageFormatPropertiesNV getPhysicalDeviceExternalImageFormatPropertiesNV(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags,
        VkExternalMemoryHandleTypeFlagsNV externalHandleType);


#define VK_NV_external_memory 1
#define VK_NV_EXTERNAL_MEMORY_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"

typedef struct VkExternalMemoryImageCreateInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExternalMemoryImageCreateInfoNV;

typedef struct VkExportMemoryAllocateInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExportMemoryAllocateInfoNV;


VkExternalMemoryImageCreateInfoNV ExternalMemoryImageCreateInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleTypes);


VkExportMemoryAllocateInfoNV ExportMemoryAllocateInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleTypes);



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_external_memory_win32 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"

typedef struct VkImportMemoryWin32HandleInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleType;
    HANDLE                               handle;
} VkImportMemoryWin32HandleInfoNV;

typedef struct VkExportMemoryWin32HandleInfoNV {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
} VkExportMemoryWin32HandleInfoNV;

struct VkExportMemoryWin32HandleInfoNVRAII {
   VkExportMemoryWin32HandleInfoNV nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};


typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);

VkImportMemoryWin32HandleInfoNV ImportMemoryWin32HandleInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE                                      handle);


std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> ExportMemoryWin32HandleInfoNV(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess);


std::shared_ptr< HANDLE > getMemoryWin32HandleNV(
        VkDevice device,
        VkDeviceMemory memory,
        VkExternalMemoryHandleTypeFlagsNV handleType);

#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_win32_keyed_mutex 1
#define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"

typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 acquireCount;
    const VkDeviceMemory*    pAcquireSyncs;
    const uint64_t*          pAcquireKeys;
    const uint32_t*          pAcquireTimeoutMilliseconds;
    uint32_t                 releaseCount;
    const VkDeviceMemory*    pReleaseSyncs;
    const uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoNV;

struct VkWin32KeyedMutexAcquireReleaseInfoNVRAII {
   VkWin32KeyedMutexAcquireReleaseInfoNV nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeoutMilliseconds;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};


std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> Win32KeyedMutexAcquireReleaseInfoNV(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeoutMilliseconds_in_array1, int pAcquireTimeoutMilliseconds_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys);


#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_EXT_validation_flags 1
#define VK_EXT_VALIDATION_FLAGS_SPEC_VERSION 1
#define VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME "VK_EXT_validation_flags"


typedef enum VkValidationCheckEXT {
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_BEGIN_RANGE_EXT = VK_VALIDATION_CHECK_ALL_EXT,
    VK_VALIDATION_CHECK_END_RANGE_EXT = VK_VALIDATION_CHECK_ALL_EXT,
    VK_VALIDATION_CHECK_RANGE_SIZE_EXT = (VK_VALIDATION_CHECK_ALL_EXT - VK_VALIDATION_CHECK_ALL_EXT + 1),
    VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF
} VkValidationCheckEXT;

typedef struct VkValidationFlagsEXT {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 disabledValidationCheckCount;
    VkValidationCheckEXT*    pDisabledValidationChecks;
} VkValidationFlagsEXT;

struct VkValidationFlagsEXTRAII {
   VkValidationFlagsEXT nonRaiiObj;
    std::vector<VkValidationCheckEXT>           vecDisabledValidationChecks;
};


std::shared_ptr<VkValidationFlagsEXTRAII> ValidationFlagsEXT(
    const std::vector<VkValidationCheckEXT> &   vecDisabledValidationChecks);


void load_vulkan_fct_ptrs(VkInstance instance);

%{

     const char* vkGetErrorString(VkResult retval)
     {
         static const char vk_err_messages[25][123] = {
             "Vulkan error (VK_SUCCESS) : Command completed successfully",
             "Vulkan error (VK_NOT_READY) : A fence or query has not yet completed",
             "Vulkan error (VK_TIMEOUT) : A wait operation has not completed in the specified time",
             "Vulkan error (VK_EVENT_SET) : An event is signaled",
             "Vulkan error (VK_EVENT_RESET) : An event is unsignaled",
             "Vulkan error (VK_INCOMPLETE) : A return array was too small for the result",
             "Vulkan error (VK_ERROR_OUT_OF_HOST_MEMORY) : A host memory allocation has failed",
             "Vulkan error (VK_ERROR_OUT_OF_DEVICE_MEMORY) : A device memory allocation has failed",
             "Vulkan error (VK_ERROR_INITIALIZATION_FAILED) : Initialization of a object has failed",
             "Vulkan error (VK_ERROR_DEVICE_LOST) : The logical device has been lost. See <<devsandqueues-lost-device>>",
             "Vulkan error (VK_ERROR_MEMORY_MAP_FAILED) : Mapping of a memory object has failed",
             "Vulkan error (VK_ERROR_LAYER_NOT_PRESENT) : Layer specified does not exist",
             "Vulkan error (VK_ERROR_EXTENSION_NOT_PRESENT) : Extension specified does not exist",
             "Vulkan error (VK_ERROR_FEATURE_NOT_PRESENT) : Requested feature is not available on this device",
             "Vulkan error (VK_ERROR_INCOMPATIBLE_DRIVER) : Unable to find a Vulkan driver",
             "Vulkan error (VK_ERROR_TOO_MANY_OBJECTS) : Too many objects of the type have already been created",
             "Vulkan error (VK_ERROR_FORMAT_NOT_SUPPORTED) : Requested format is not supported on this device",
             "Vulkan error (VK_ERROR_FRAGMENTED_POOL) : A requested pool allocation has failed due to fragmentation of the pool's memory",
             "Vulkan error: VK_ERROR_SURFACE_LOST_KHR",
             "Vulkan error: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR",
             "Vulkan error: VK_SUBOPTIMAL_KHR",
             "Vulkan error: VK_ERROR_OUT_OF_DATE_KHR",
             "Vulkan error: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR",
             "Vulkan error: VK_ERROR_VALIDATION_FAILED_EXT",
             "Vulkan error: VK_ERROR_INVALID_SHADER_NV",
         };
         switch (retval) {
             case VK_SUCCESS : return vk_err_messages[0];
             case VK_NOT_READY : return vk_err_messages[1];
             case VK_TIMEOUT : return vk_err_messages[2];
             case VK_EVENT_SET : return vk_err_messages[3];
             case VK_EVENT_RESET : return vk_err_messages[4];
             case VK_INCOMPLETE : return vk_err_messages[5];
             case VK_ERROR_OUT_OF_HOST_MEMORY : return vk_err_messages[6];
             case VK_ERROR_OUT_OF_DEVICE_MEMORY : return vk_err_messages[7];
             case VK_ERROR_INITIALIZATION_FAILED : return vk_err_messages[8];
             case VK_ERROR_DEVICE_LOST : return vk_err_messages[9];
             case VK_ERROR_MEMORY_MAP_FAILED : return vk_err_messages[10];
             case VK_ERROR_LAYER_NOT_PRESENT : return vk_err_messages[11];
             case VK_ERROR_EXTENSION_NOT_PRESENT : return vk_err_messages[12];
             case VK_ERROR_FEATURE_NOT_PRESENT : return vk_err_messages[13];
             case VK_ERROR_INCOMPATIBLE_DRIVER : return vk_err_messages[14];
             case VK_ERROR_TOO_MANY_OBJECTS : return vk_err_messages[15];
             case VK_ERROR_FORMAT_NOT_SUPPORTED : return vk_err_messages[16];
             case VK_ERROR_FRAGMENTED_POOL : return vk_err_messages[17];
             case VK_ERROR_SURFACE_LOST_KHR : return vk_err_messages[18];
             case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR : return vk_err_messages[19];
             case VK_SUBOPTIMAL_KHR : return vk_err_messages[20];
             case VK_ERROR_OUT_OF_DATE_KHR : return vk_err_messages[21];
             case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR : return vk_err_messages[22];
             case VK_ERROR_VALIDATION_FAILED_EXT : return vk_err_messages[23];
             case VK_ERROR_INVALID_SHADER_NV : return vk_err_messages[24];
         }
         return nullptr;
     }

PFN_vkGetPhysicalDeviceDisplayPropertiesKHR pfvkGetPhysicalDeviceDisplayPropertiesKHR;
    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    PFN_vkGetDisplayPlaneSupportedDisplaysKHR pfvkGetDisplayPlaneSupportedDisplaysKHR;
    PFN_vkGetDisplayModePropertiesKHR pfvkGetDisplayModePropertiesKHR;
    PFN_vkCreateDisplayModeKHR pfvkCreateDisplayModeKHR;
    PFN_vkGetDisplayPlaneCapabilitiesKHR pfvkGetDisplayPlaneCapabilitiesKHR;
    PFN_vkCreateDisplayPlaneSurfaceKHR pfvkCreateDisplayPlaneSurfaceKHR;
    PFN_vkCreateSharedSwapchainsKHR pfvkCreateSharedSwapchainsKHR;
    PFN_vkCreateDebugReportCallbackEXT pfvkCreateDebugReportCallbackEXT;
    PFN_vkDestroyDebugReportCallbackEXT pfvkDestroyDebugReportCallbackEXT;
    PFN_vkDebugReportMessageEXT pfvkDebugReportMessageEXT;
    PFN_vkDebugMarkerSetObjectTagEXT pfvkDebugMarkerSetObjectTagEXT;
    PFN_vkDebugMarkerSetObjectNameEXT pfvkDebugMarkerSetObjectNameEXT;
    PFN_vkCmdDebugMarkerBeginEXT pfvkCmdDebugMarkerBeginEXT;
    PFN_vkCmdDebugMarkerEndEXT pfvkCmdDebugMarkerEndEXT;
    PFN_vkCmdDebugMarkerInsertEXT pfvkCmdDebugMarkerInsertEXT;
    PFN_vkCmdDrawIndirectCountAMD pfvkCmdDrawIndirectCountAMD;
    PFN_vkCmdDrawIndexedIndirectCountAMD pfvkCmdDrawIndexedIndirectCountAMD;
    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV pfvkGetPhysicalDeviceExternalImageFormatPropertiesNV;
    PFN_vkGetMemoryWin32HandleNV pfvkGetMemoryWin32HandleNV;

    void load_vulkan_fct_ptrs(VkInstance instance)
    {
	    pfvkGetPhysicalDeviceDisplayPropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR"));
	    pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR"));
	    pfvkGetDisplayPlaneSupportedDisplaysKHR = reinterpret_cast<PFN_vkGetDisplayPlaneSupportedDisplaysKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR"));
	    pfvkGetDisplayModePropertiesKHR = reinterpret_cast<PFN_vkGetDisplayModePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayModePropertiesKHR"));
	    pfvkCreateDisplayModeKHR = reinterpret_cast<PFN_vkCreateDisplayModeKHR>(vkGetInstanceProcAddr(instance, "vkCreateDisplayModeKHR"));
	    pfvkGetDisplayPlaneCapabilitiesKHR = reinterpret_cast<PFN_vkGetDisplayPlaneCapabilitiesKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilitiesKHR"));
	    pfvkCreateDisplayPlaneSurfaceKHR = reinterpret_cast<PFN_vkCreateDisplayPlaneSurfaceKHR>(vkGetInstanceProcAddr(instance, "vkCreateDisplayPlaneSurfaceKHR"));
	    pfvkCreateSharedSwapchainsKHR = reinterpret_cast<PFN_vkCreateSharedSwapchainsKHR>(vkGetInstanceProcAddr(instance, "vkCreateSharedSwapchainsKHR"));
	    pfvkCreateDebugReportCallbackEXT = reinterpret_cast<PFN_vkCreateDebugReportCallbackEXT>(vkGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT"));
	    pfvkDestroyDebugReportCallbackEXT = reinterpret_cast<PFN_vkDestroyDebugReportCallbackEXT>(vkGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT"));
	    pfvkDebugReportMessageEXT = reinterpret_cast<PFN_vkDebugReportMessageEXT>(vkGetInstanceProcAddr(instance, "vkDebugReportMessageEXT"));
	    pfvkDebugMarkerSetObjectTagEXT = reinterpret_cast<PFN_vkDebugMarkerSetObjectTagEXT>(vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectTagEXT"));
	    pfvkDebugMarkerSetObjectNameEXT = reinterpret_cast<PFN_vkDebugMarkerSetObjectNameEXT>(vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectNameEXT"));
	    pfvkCmdDebugMarkerBeginEXT = reinterpret_cast<PFN_vkCmdDebugMarkerBeginEXT>(vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerBeginEXT"));
	    pfvkCmdDebugMarkerEndEXT = reinterpret_cast<PFN_vkCmdDebugMarkerEndEXT>(vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerEndEXT"));
	    pfvkCmdDebugMarkerInsertEXT = reinterpret_cast<PFN_vkCmdDebugMarkerInsertEXT>(vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerInsertEXT"));
	    pfvkCmdDrawIndirectCountAMD = reinterpret_cast<PFN_vkCmdDrawIndirectCountAMD>(vkGetInstanceProcAddr(instance, "vkCmdDrawIndirectCountAMD"));
	    pfvkCmdDrawIndexedIndirectCountAMD = reinterpret_cast<PFN_vkCmdDrawIndexedIndirectCountAMD>(vkGetInstanceProcAddr(instance, "vkCmdDrawIndexedIndirectCountAMD"));
	    pfvkGetPhysicalDeviceExternalImageFormatPropertiesNV = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"));
	    pfvkGetMemoryWin32HandleNV = reinterpret_cast<PFN_vkGetMemoryWin32HandleNV>(vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandleNV"));
  }
%}

%{

struct VkApplicationInfoRAII {
   VkApplicationInfo nonRaiiObj;
    std::string                                 strApplicationName;
    std::string                                 strEngineName;
};

std::shared_ptr<VkApplicationInfoRAII> ApplicationInfo(
    const std::string &                         strApplicationName,
    uint32_t                                    applicationVersion,
    const std::string &                         strEngineName,
    uint32_t                                    engineVersion,
    uint32_t                                    apiVersion)
   {
      std::shared_ptr<VkApplicationInfoRAII> raii_obj(new VkApplicationInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->strApplicationName = strApplicationName;
      raii_obj->nonRaiiObj.pApplicationName = &raii_obj->strApplicationName[0];
      raii_obj->nonRaiiObj.applicationVersion = applicationVersion;
      raii_obj->strEngineName = strEngineName;
      raii_obj->nonRaiiObj.pEngineName = &raii_obj->strEngineName[0];
      raii_obj->nonRaiiObj.engineVersion = engineVersion;
      raii_obj->nonRaiiObj.apiVersion = apiVersion;
      return raii_obj;
   }

struct VkInstanceCreateInfoRAII {
   VkInstanceCreateInfo nonRaiiObj;
    std::shared_ptr<VkApplicationInfoRAII>      pApplicationInfo;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
};

std::shared_ptr<VkInstanceCreateInfoRAII> InstanceCreateInfo(
    VkInstanceCreateFlags                       flags,
    const std::shared_ptr<VkApplicationInfoRAII> &pApplicationInfo,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames)
   {
      std::shared_ptr<VkInstanceCreateInfoRAII> raii_obj(new VkInstanceCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->pApplicationInfo = pApplicationInfo;
      if ( pApplicationInfo ) 
      {
          raii_obj->nonRaiiObj.pApplicationInfo = &(pApplicationInfo->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pApplicationInfo = nullptr;
      }
      raii_obj->nonRaiiObj.enabledLayerCount = static_cast<uint32_t>(vecEnabledLayerNames.size());
      raii_obj->vecEnabledLayerNames = vecEnabledLayerNames;
      raii_obj->vecPtrEnabledLayerNames.resize(vecEnabledLayerNames.size());
      for (size_t i=0; i<vecEnabledLayerNames.size(); ++i) 
           raii_obj->vecPtrEnabledLayerNames[i] = raii_obj->vecEnabledLayerNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledLayerNames = &raii_obj->vecPtrEnabledLayerNames[0];
      raii_obj->nonRaiiObj.enabledExtensionCount = static_cast<uint32_t>(vecEnabledExtensionNames.size());
      raii_obj->vecEnabledExtensionNames = vecEnabledExtensionNames;
      raii_obj->vecPtrEnabledExtensionNames.resize(vecEnabledExtensionNames.size());
      for (size_t i=0; i<vecEnabledExtensionNames.size(); ++i) 
           raii_obj->vecPtrEnabledExtensionNames[i] = raii_obj->vecEnabledExtensionNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledExtensionNames = &raii_obj->vecPtrEnabledExtensionNames[0];
      return raii_obj;
   }

VkAllocationCallbacks AllocationCallbacks(
    PFN_vkAllocationFunction                    pfnAllocation,
    PFN_vkReallocationFunction                  pfnReallocation,
    PFN_vkFreeFunction                          pfnFree,
    PFN_vkInternalAllocationNotification        pfnInternalAllocation,
    PFN_vkInternalFreeNotification              pfnInternalFree)
   {
      VkAllocationCallbacks obj;
      obj.pUserData = nullptr;
      obj.pfnAllocation = pfnAllocation;
      obj.pfnReallocation = pfnReallocation;
      obj.pfnFree = pfnFree;
      obj.pfnInternalAllocation = pfnInternalAllocation;
      obj.pfnInternalFree = pfnInternalFree;
      return obj;
   }

std::shared_ptr<VkInstance_T> createInstance(
        const VkInstanceCreateInfo & pCreateInfo)
   {
      VkInstance hInstance; 
      V( vkCreateInstance(
          &pCreateInfo,
          nullptr,
          &hInstance  ));
      return std::shared_ptr<VkInstance_T>(hInstance, 
              [=](VkInstance to_free) {vkDestroyInstance( to_free, nullptr);});
   }

std::vector< VkPhysicalDevice > enumeratePhysicalDevices(
        VkInstance instance)
   {
      std::vector<VkPhysicalDevice> vecpPhysicalDevices; 
      uint32_t pPhysicalDevicesCount; 
      V( vkEnumeratePhysicalDevices(
          instance,
          &pPhysicalDevicesCount,
          nullptr  ));

      vecpPhysicalDevices.resize(pPhysicalDevicesCount); 

      V( vkEnumeratePhysicalDevices(
          instance,
          &pPhysicalDevicesCount,
          &vecpPhysicalDevices[0]  ));
      return vecpPhysicalDevices; 
   }

VkPhysicalDeviceFeatures PhysicalDeviceFeatures(
    VkBool32                                    robustBufferAccess,
    VkBool32                                    fullDrawIndexUint32,
    VkBool32                                    imageCubeArray,
    VkBool32                                    independentBlend,
    VkBool32                                    geometryShader,
    VkBool32                                    tessellationShader,
    VkBool32                                    sampleRateShading,
    VkBool32                                    dualSrcBlend,
    VkBool32                                    logicOp,
    VkBool32                                    multiDrawIndirect,
    VkBool32                                    drawIndirectFirstInstance,
    VkBool32                                    depthClamp,
    VkBool32                                    depthBiasClamp,
    VkBool32                                    fillModeNonSolid,
    VkBool32                                    depthBounds,
    VkBool32                                    wideLines,
    VkBool32                                    largePoints,
    VkBool32                                    alphaToOne,
    VkBool32                                    multiViewport,
    VkBool32                                    samplerAnisotropy,
    VkBool32                                    textureCompressionETC2,
    VkBool32                                    textureCompressionASTC_LDR,
    VkBool32                                    textureCompressionBC,
    VkBool32                                    occlusionQueryPrecise,
    VkBool32                                    pipelineStatisticsQuery,
    VkBool32                                    vertexPipelineStoresAndAtomics,
    VkBool32                                    fragmentStoresAndAtomics,
    VkBool32                                    shaderTessellationAndGeometryPointSize,
    VkBool32                                    shaderImageGatherExtended,
    VkBool32                                    shaderStorageImageExtendedFormats,
    VkBool32                                    shaderStorageImageMultisample,
    VkBool32                                    shaderStorageImageReadWithoutFormat,
    VkBool32                                    shaderStorageImageWriteWithoutFormat,
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing,
    VkBool32                                    shaderSampledImageArrayDynamicIndexing,
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing,
    VkBool32                                    shaderStorageImageArrayDynamicIndexing,
    VkBool32                                    shaderClipDistance,
    VkBool32                                    shaderCullDistance,
    VkBool32                                    shaderFloat64,
    VkBool32                                    shaderInt64,
    VkBool32                                    shaderInt16,
    VkBool32                                    shaderResourceResidency,
    VkBool32                                    shaderResourceMinLod,
    VkBool32                                    sparseBinding,
    VkBool32                                    sparseResidencyBuffer,
    VkBool32                                    sparseResidencyImage2D,
    VkBool32                                    sparseResidencyImage3D,
    VkBool32                                    sparseResidency2Samples,
    VkBool32                                    sparseResidency4Samples,
    VkBool32                                    sparseResidency8Samples,
    VkBool32                                    sparseResidency16Samples,
    VkBool32                                    sparseResidencyAliased,
    VkBool32                                    variableMultisampleRate,
    VkBool32                                    inheritedQueries)
   {
      VkPhysicalDeviceFeatures obj;
      obj.robustBufferAccess = robustBufferAccess;
      obj.fullDrawIndexUint32 = fullDrawIndexUint32;
      obj.imageCubeArray = imageCubeArray;
      obj.independentBlend = independentBlend;
      obj.geometryShader = geometryShader;
      obj.tessellationShader = tessellationShader;
      obj.sampleRateShading = sampleRateShading;
      obj.dualSrcBlend = dualSrcBlend;
      obj.logicOp = logicOp;
      obj.multiDrawIndirect = multiDrawIndirect;
      obj.drawIndirectFirstInstance = drawIndirectFirstInstance;
      obj.depthClamp = depthClamp;
      obj.depthBiasClamp = depthBiasClamp;
      obj.fillModeNonSolid = fillModeNonSolid;
      obj.depthBounds = depthBounds;
      obj.wideLines = wideLines;
      obj.largePoints = largePoints;
      obj.alphaToOne = alphaToOne;
      obj.multiViewport = multiViewport;
      obj.samplerAnisotropy = samplerAnisotropy;
      obj.textureCompressionETC2 = textureCompressionETC2;
      obj.textureCompressionASTC_LDR = textureCompressionASTC_LDR;
      obj.textureCompressionBC = textureCompressionBC;
      obj.occlusionQueryPrecise = occlusionQueryPrecise;
      obj.pipelineStatisticsQuery = pipelineStatisticsQuery;
      obj.vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics;
      obj.fragmentStoresAndAtomics = fragmentStoresAndAtomics;
      obj.shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize;
      obj.shaderImageGatherExtended = shaderImageGatherExtended;
      obj.shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats;
      obj.shaderStorageImageMultisample = shaderStorageImageMultisample;
      obj.shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat;
      obj.shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat;
      obj.shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing;
      obj.shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing;
      obj.shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing;
      obj.shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing;
      obj.shaderClipDistance = shaderClipDistance;
      obj.shaderCullDistance = shaderCullDistance;
      obj.shaderFloat64 = shaderFloat64;
      obj.shaderInt64 = shaderInt64;
      obj.shaderInt16 = shaderInt16;
      obj.shaderResourceResidency = shaderResourceResidency;
      obj.shaderResourceMinLod = shaderResourceMinLod;
      obj.sparseBinding = sparseBinding;
      obj.sparseResidencyBuffer = sparseResidencyBuffer;
      obj.sparseResidencyImage2D = sparseResidencyImage2D;
      obj.sparseResidencyImage3D = sparseResidencyImage3D;
      obj.sparseResidency2Samples = sparseResidency2Samples;
      obj.sparseResidency4Samples = sparseResidency4Samples;
      obj.sparseResidency8Samples = sparseResidency8Samples;
      obj.sparseResidency16Samples = sparseResidency16Samples;
      obj.sparseResidencyAliased = sparseResidencyAliased;
      obj.variableMultisampleRate = variableMultisampleRate;
      obj.inheritedQueries = inheritedQueries;
      return obj;
   }

VkPhysicalDeviceFeatures getPhysicalDeviceFeatures(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceFeatures pFeatures; 
      vkGetPhysicalDeviceFeatures(
          physicalDevice,
          &pFeatures  );
      return pFeatures; 
   }

VkFormatProperties FormatProperties(
    VkFormatFeatureFlags                        linearTilingFeatures,
    VkFormatFeatureFlags                        optimalTilingFeatures,
    VkFormatFeatureFlags                        bufferFeatures)
   {
      VkFormatProperties obj;
      obj.linearTilingFeatures = linearTilingFeatures;
      obj.optimalTilingFeatures = optimalTilingFeatures;
      obj.bufferFeatures = bufferFeatures;
      return obj;
   }

VkFormatProperties getPhysicalDeviceFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format)
   {
      VkFormatProperties pFormatProperties; 
      vkGetPhysicalDeviceFormatProperties(
          physicalDevice,
          format,
          &pFormatProperties  );
      return pFormatProperties; 
   }

VkExtent3D Extent3D(
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
   {
      VkExtent3D obj;
      obj.width = width;
      obj.height = height;
      obj.depth = depth;
      return obj;
   }

VkImageFormatProperties ImageFormatProperties(
    VkExtent3D                                  maxExtent,
    uint32_t                                    maxMipLevels,
    uint32_t                                    maxArrayLayers,
    VkSampleCountFlags                          sampleCounts,
    VkDeviceSize                                maxResourceSize)
   {
      VkImageFormatProperties obj;
      obj.maxExtent = maxExtent;
      obj.maxMipLevels = maxMipLevels;
      obj.maxArrayLayers = maxArrayLayers;
      obj.sampleCounts = sampleCounts;
      obj.maxResourceSize = maxResourceSize;
      return obj;
   }

VkImageFormatProperties getPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags)
   {
      VkImageFormatProperties pImageFormatProperties; 
      V( vkGetPhysicalDeviceImageFormatProperties(
          physicalDevice,
          format,
          type,
          tiling,
          usage,
          flags,
          &pImageFormatProperties  ));
      return pImageFormatProperties; 
   }

VkPhysicalDeviceLimits PhysicalDeviceLimits(
    uint32_t                                    maxImageDimension1D,
    uint32_t                                    maxImageDimension2D,
    uint32_t                                    maxImageDimension3D,
    uint32_t                                    maxImageDimensionCube,
    uint32_t                                    maxImageArrayLayers,
    uint32_t                                    maxTexelBufferElements,
    uint32_t                                    maxUniformBufferRange,
    uint32_t                                    maxStorageBufferRange,
    uint32_t                                    maxPushConstantsSize,
    uint32_t                                    maxMemoryAllocationCount,
    uint32_t                                    maxSamplerAllocationCount,
    VkDeviceSize                                bufferImageGranularity,
    VkDeviceSize                                sparseAddressSpaceSize,
    uint32_t                                    maxBoundDescriptorSets,
    uint32_t                                    maxPerStageDescriptorSamplers,
    uint32_t                                    maxPerStageDescriptorUniformBuffers,
    uint32_t                                    maxPerStageDescriptorStorageBuffers,
    uint32_t                                    maxPerStageDescriptorSampledImages,
    uint32_t                                    maxPerStageDescriptorStorageImages,
    uint32_t                                    maxPerStageDescriptorInputAttachments,
    uint32_t                                    maxPerStageResources,
    uint32_t                                    maxDescriptorSetSamplers,
    uint32_t                                    maxDescriptorSetUniformBuffers,
    uint32_t                                    maxDescriptorSetUniformBuffersDynamic,
    uint32_t                                    maxDescriptorSetStorageBuffers,
    uint32_t                                    maxDescriptorSetStorageBuffersDynamic,
    uint32_t                                    maxDescriptorSetSampledImages,
    uint32_t                                    maxDescriptorSetStorageImages,
    uint32_t                                    maxDescriptorSetInputAttachments,
    uint32_t                                    maxVertexInputAttributes,
    uint32_t                                    maxVertexInputBindings,
    uint32_t                                    maxVertexInputAttributeOffset,
    uint32_t                                    maxVertexInputBindingStride,
    uint32_t                                    maxVertexOutputComponents,
    uint32_t                                    maxTessellationGenerationLevel,
    uint32_t                                    maxTessellationPatchSize,
    uint32_t                                    maxTessellationControlPerVertexInputComponents,
    uint32_t                                    maxTessellationControlPerVertexOutputComponents,
    uint32_t                                    maxTessellationControlPerPatchOutputComponents,
    uint32_t                                    maxTessellationControlTotalOutputComponents,
    uint32_t                                    maxTessellationEvaluationInputComponents,
    uint32_t                                    maxTessellationEvaluationOutputComponents,
    uint32_t                                    maxGeometryShaderInvocations,
    uint32_t                                    maxGeometryInputComponents,
    uint32_t                                    maxGeometryOutputComponents,
    uint32_t                                    maxGeometryOutputVertices,
    uint32_t                                    maxGeometryTotalOutputComponents,
    uint32_t                                    maxFragmentInputComponents,
    uint32_t                                    maxFragmentOutputAttachments,
    uint32_t                                    maxFragmentDualSrcAttachments,
    uint32_t                                    maxFragmentCombinedOutputResources,
    uint32_t                                    maxComputeSharedMemorySize,
    uint32_t                                    maxComputeWorkGroupCount[3],
    uint32_t                                    maxComputeWorkGroupInvocations,
    uint32_t                                    maxComputeWorkGroupSize[3],
    uint32_t                                    subPixelPrecisionBits,
    uint32_t                                    subTexelPrecisionBits,
    uint32_t                                    mipmapPrecisionBits,
    uint32_t                                    maxDrawIndexedIndexValue,
    uint32_t                                    maxDrawIndirectCount,
    float                                       maxSamplerLodBias,
    float                                       maxSamplerAnisotropy,
    uint32_t                                    maxViewports,
    uint32_t                                    maxViewportDimensions[2],
    float                                       viewportBoundsRange[2],
    uint32_t                                    viewportSubPixelBits,
    size_t                                      minMemoryMapAlignment,
    VkDeviceSize                                minTexelBufferOffsetAlignment,
    VkDeviceSize                                minUniformBufferOffsetAlignment,
    VkDeviceSize                                minStorageBufferOffsetAlignment,
    int32_t                                     minTexelOffset,
    uint32_t                                    maxTexelOffset,
    int32_t                                     minTexelGatherOffset,
    uint32_t                                    maxTexelGatherOffset,
    float                                       minInterpolationOffset,
    float                                       maxInterpolationOffset,
    uint32_t                                    subPixelInterpolationOffsetBits,
    uint32_t                                    maxFramebufferWidth,
    uint32_t                                    maxFramebufferHeight,
    uint32_t                                    maxFramebufferLayers,
    VkSampleCountFlags                          framebufferColorSampleCounts,
    VkSampleCountFlags                          framebufferDepthSampleCounts,
    VkSampleCountFlags                          framebufferStencilSampleCounts,
    VkSampleCountFlags                          framebufferNoAttachmentsSampleCounts,
    uint32_t                                    maxColorAttachments,
    VkSampleCountFlags                          sampledImageColorSampleCounts,
    VkSampleCountFlags                          sampledImageIntegerSampleCounts,
    VkSampleCountFlags                          sampledImageDepthSampleCounts,
    VkSampleCountFlags                          sampledImageStencilSampleCounts,
    VkSampleCountFlags                          storageImageSampleCounts,
    uint32_t                                    maxSampleMaskWords,
    VkBool32                                    timestampComputeAndGraphics,
    float                                       timestampPeriod,
    uint32_t                                    maxClipDistances,
    uint32_t                                    maxCullDistances,
    uint32_t                                    maxCombinedClipAndCullDistances,
    uint32_t                                    discreteQueuePriorities,
    float                                       pointSizeRange[2],
    float                                       lineWidthRange[2],
    float                                       pointSizeGranularity,
    float                                       lineWidthGranularity,
    VkBool32                                    strictLines,
    VkBool32                                    standardSampleLocations,
    VkDeviceSize                                optimalBufferCopyOffsetAlignment,
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment,
    VkDeviceSize                                nonCoherentAtomSize)
   {
      VkPhysicalDeviceLimits obj;
      obj.maxImageDimension1D = maxImageDimension1D;
      obj.maxImageDimension2D = maxImageDimension2D;
      obj.maxImageDimension3D = maxImageDimension3D;
      obj.maxImageDimensionCube = maxImageDimensionCube;
      obj.maxImageArrayLayers = maxImageArrayLayers;
      obj.maxTexelBufferElements = maxTexelBufferElements;
      obj.maxUniformBufferRange = maxUniformBufferRange;
      obj.maxStorageBufferRange = maxStorageBufferRange;
      obj.maxPushConstantsSize = maxPushConstantsSize;
      obj.maxMemoryAllocationCount = maxMemoryAllocationCount;
      obj.maxSamplerAllocationCount = maxSamplerAllocationCount;
      obj.bufferImageGranularity = bufferImageGranularity;
      obj.sparseAddressSpaceSize = sparseAddressSpaceSize;
      obj.maxBoundDescriptorSets = maxBoundDescriptorSets;
      obj.maxPerStageDescriptorSamplers = maxPerStageDescriptorSamplers;
      obj.maxPerStageDescriptorUniformBuffers = maxPerStageDescriptorUniformBuffers;
      obj.maxPerStageDescriptorStorageBuffers = maxPerStageDescriptorStorageBuffers;
      obj.maxPerStageDescriptorSampledImages = maxPerStageDescriptorSampledImages;
      obj.maxPerStageDescriptorStorageImages = maxPerStageDescriptorStorageImages;
      obj.maxPerStageDescriptorInputAttachments = maxPerStageDescriptorInputAttachments;
      obj.maxPerStageResources = maxPerStageResources;
      obj.maxDescriptorSetSamplers = maxDescriptorSetSamplers;
      obj.maxDescriptorSetUniformBuffers = maxDescriptorSetUniformBuffers;
      obj.maxDescriptorSetUniformBuffersDynamic = maxDescriptorSetUniformBuffersDynamic;
      obj.maxDescriptorSetStorageBuffers = maxDescriptorSetStorageBuffers;
      obj.maxDescriptorSetStorageBuffersDynamic = maxDescriptorSetStorageBuffersDynamic;
      obj.maxDescriptorSetSampledImages = maxDescriptorSetSampledImages;
      obj.maxDescriptorSetStorageImages = maxDescriptorSetStorageImages;
      obj.maxDescriptorSetInputAttachments = maxDescriptorSetInputAttachments;
      obj.maxVertexInputAttributes = maxVertexInputAttributes;
      obj.maxVertexInputBindings = maxVertexInputBindings;
      obj.maxVertexInputAttributeOffset = maxVertexInputAttributeOffset;
      obj.maxVertexInputBindingStride = maxVertexInputBindingStride;
      obj.maxVertexOutputComponents = maxVertexOutputComponents;
      obj.maxTessellationGenerationLevel = maxTessellationGenerationLevel;
      obj.maxTessellationPatchSize = maxTessellationPatchSize;
      obj.maxTessellationControlPerVertexInputComponents = maxTessellationControlPerVertexInputComponents;
      obj.maxTessellationControlPerVertexOutputComponents = maxTessellationControlPerVertexOutputComponents;
      obj.maxTessellationControlPerPatchOutputComponents = maxTessellationControlPerPatchOutputComponents;
      obj.maxTessellationControlTotalOutputComponents = maxTessellationControlTotalOutputComponents;
      obj.maxTessellationEvaluationInputComponents = maxTessellationEvaluationInputComponents;
      obj.maxTessellationEvaluationOutputComponents = maxTessellationEvaluationOutputComponents;
      obj.maxGeometryShaderInvocations = maxGeometryShaderInvocations;
      obj.maxGeometryInputComponents = maxGeometryInputComponents;
      obj.maxGeometryOutputComponents = maxGeometryOutputComponents;
      obj.maxGeometryOutputVertices = maxGeometryOutputVertices;
      obj.maxGeometryTotalOutputComponents = maxGeometryTotalOutputComponents;
      obj.maxFragmentInputComponents = maxFragmentInputComponents;
      obj.maxFragmentOutputAttachments = maxFragmentOutputAttachments;
      obj.maxFragmentDualSrcAttachments = maxFragmentDualSrcAttachments;
      obj.maxFragmentCombinedOutputResources = maxFragmentCombinedOutputResources;
      obj.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
      std::copy(maxComputeWorkGroupCount, maxComputeWorkGroupCount + 3, obj.maxComputeWorkGroupCount);
      obj.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
      std::copy(maxComputeWorkGroupSize, maxComputeWorkGroupSize + 3, obj.maxComputeWorkGroupSize);
      obj.subPixelPrecisionBits = subPixelPrecisionBits;
      obj.subTexelPrecisionBits = subTexelPrecisionBits;
      obj.mipmapPrecisionBits = mipmapPrecisionBits;
      obj.maxDrawIndexedIndexValue = maxDrawIndexedIndexValue;
      obj.maxDrawIndirectCount = maxDrawIndirectCount;
      obj.maxSamplerLodBias = maxSamplerLodBias;
      obj.maxSamplerAnisotropy = maxSamplerAnisotropy;
      obj.maxViewports = maxViewports;
      std::copy(maxViewportDimensions, maxViewportDimensions + 2, obj.maxViewportDimensions);
      std::copy(viewportBoundsRange, viewportBoundsRange + 2, obj.viewportBoundsRange);
      obj.viewportSubPixelBits = viewportSubPixelBits;
      obj.minMemoryMapAlignment = minMemoryMapAlignment;
      obj.minTexelBufferOffsetAlignment = minTexelBufferOffsetAlignment;
      obj.minUniformBufferOffsetAlignment = minUniformBufferOffsetAlignment;
      obj.minStorageBufferOffsetAlignment = minStorageBufferOffsetAlignment;
      obj.minTexelOffset = minTexelOffset;
      obj.maxTexelOffset = maxTexelOffset;
      obj.minTexelGatherOffset = minTexelGatherOffset;
      obj.maxTexelGatherOffset = maxTexelGatherOffset;
      obj.minInterpolationOffset = minInterpolationOffset;
      obj.maxInterpolationOffset = maxInterpolationOffset;
      obj.subPixelInterpolationOffsetBits = subPixelInterpolationOffsetBits;
      obj.maxFramebufferWidth = maxFramebufferWidth;
      obj.maxFramebufferHeight = maxFramebufferHeight;
      obj.maxFramebufferLayers = maxFramebufferLayers;
      obj.framebufferColorSampleCounts = framebufferColorSampleCounts;
      obj.framebufferDepthSampleCounts = framebufferDepthSampleCounts;
      obj.framebufferStencilSampleCounts = framebufferStencilSampleCounts;
      obj.framebufferNoAttachmentsSampleCounts = framebufferNoAttachmentsSampleCounts;
      obj.maxColorAttachments = maxColorAttachments;
      obj.sampledImageColorSampleCounts = sampledImageColorSampleCounts;
      obj.sampledImageIntegerSampleCounts = sampledImageIntegerSampleCounts;
      obj.sampledImageDepthSampleCounts = sampledImageDepthSampleCounts;
      obj.sampledImageStencilSampleCounts = sampledImageStencilSampleCounts;
      obj.storageImageSampleCounts = storageImageSampleCounts;
      obj.maxSampleMaskWords = maxSampleMaskWords;
      obj.timestampComputeAndGraphics = timestampComputeAndGraphics;
      obj.timestampPeriod = timestampPeriod;
      obj.maxClipDistances = maxClipDistances;
      obj.maxCullDistances = maxCullDistances;
      obj.maxCombinedClipAndCullDistances = maxCombinedClipAndCullDistances;
      obj.discreteQueuePriorities = discreteQueuePriorities;
      std::copy(pointSizeRange, pointSizeRange + 2, obj.pointSizeRange);
      std::copy(lineWidthRange, lineWidthRange + 2, obj.lineWidthRange);
      obj.pointSizeGranularity = pointSizeGranularity;
      obj.lineWidthGranularity = lineWidthGranularity;
      obj.strictLines = strictLines;
      obj.standardSampleLocations = standardSampleLocations;
      obj.optimalBufferCopyOffsetAlignment = optimalBufferCopyOffsetAlignment;
      obj.optimalBufferCopyRowPitchAlignment = optimalBufferCopyRowPitchAlignment;
      obj.nonCoherentAtomSize = nonCoherentAtomSize;
      return obj;
   }

VkPhysicalDeviceSparseProperties PhysicalDeviceSparseProperties(
    VkBool32                                    residencyStandard2DBlockShape,
    VkBool32                                    residencyStandard2DMultisampleBlockShape,
    VkBool32                                    residencyStandard3DBlockShape,
    VkBool32                                    residencyAlignedMipSize,
    VkBool32                                    residencyNonResidentStrict)
   {
      VkPhysicalDeviceSparseProperties obj;
      obj.residencyStandard2DBlockShape = residencyStandard2DBlockShape;
      obj.residencyStandard2DMultisampleBlockShape = residencyStandard2DMultisampleBlockShape;
      obj.residencyStandard3DBlockShape = residencyStandard3DBlockShape;
      obj.residencyAlignedMipSize = residencyAlignedMipSize;
      obj.residencyNonResidentStrict = residencyNonResidentStrict;
      return obj;
   }

VkPhysicalDeviceProperties PhysicalDeviceProperties(
    uint32_t                                    apiVersion,
    uint32_t                                    driverVersion,
    uint32_t                                    vendorID,
    uint32_t                                    deviceID,
    VkPhysicalDeviceType                        deviceType,
    char                                        deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    uint8_t                                     pipelineCacheUUID[VK_UUID_SIZE],
    VkPhysicalDeviceLimits                      limits,
    VkPhysicalDeviceSparseProperties            sparseProperties)
   {
      VkPhysicalDeviceProperties obj;
      obj.apiVersion = apiVersion;
      obj.driverVersion = driverVersion;
      obj.vendorID = vendorID;
      obj.deviceID = deviceID;
      obj.deviceType = deviceType;
      std::copy(deviceName, deviceName + VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, obj.deviceName);
      std::copy(pipelineCacheUUID, pipelineCacheUUID + VK_UUID_SIZE, obj.pipelineCacheUUID);
      obj.limits = limits;
      obj.sparseProperties = sparseProperties;
      return obj;
   }

VkPhysicalDeviceProperties getPhysicalDeviceProperties(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceProperties pProperties; 
      vkGetPhysicalDeviceProperties(
          physicalDevice,
          &pProperties  );
      return pProperties; 
   }

VkQueueFamilyProperties QueueFamilyProperties(
    VkQueueFlags                                queueFlags,
    uint32_t                                    queueCount,
    uint32_t                                    timestampValidBits,
    VkExtent3D                                  minImageTransferGranularity)
   {
      VkQueueFamilyProperties obj;
      obj.queueFlags = queueFlags;
      obj.queueCount = queueCount;
      obj.timestampValidBits = timestampValidBits;
      obj.minImageTransferGranularity = minImageTransferGranularity;
      return obj;
   }

std::vector< VkQueueFamilyProperties > getPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice physicalDevice)
   {
      std::vector<VkQueueFamilyProperties> vecpQueueFamilyProperties; 
      uint32_t pQueueFamilyPropertiesCount; 
      vkGetPhysicalDeviceQueueFamilyProperties(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          nullptr  );

      vecpQueueFamilyProperties.resize(pQueueFamilyPropertiesCount); 

      vkGetPhysicalDeviceQueueFamilyProperties(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          &vecpQueueFamilyProperties[0]  );
      return vecpQueueFamilyProperties; 
   }

VkMemoryType MemoryType(
    VkMemoryPropertyFlags                       propertyFlags,
    uint32_t                                    heapIndex)
   {
      VkMemoryType obj;
      obj.propertyFlags = propertyFlags;
      obj.heapIndex = heapIndex;
      return obj;
   }

VkMemoryHeap MemoryHeap(
    VkDeviceSize                                size,
    VkMemoryHeapFlags                           flags)
   {
      VkMemoryHeap obj;
      obj.size = size;
      obj.flags = flags;
      return obj;
   }

VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties(
    uint32_t                                    memoryTypeCount,
    VkMemoryType                                memoryTypes[VK_MAX_MEMORY_TYPES],
    uint32_t                                    memoryHeapCount,
    VkMemoryHeap                                memoryHeaps[VK_MAX_MEMORY_HEAPS])
   {
      VkPhysicalDeviceMemoryProperties obj;
      obj.memoryTypeCount = memoryTypeCount;
      std::copy(memoryTypes, memoryTypes + VK_MAX_MEMORY_TYPES, obj.memoryTypes);
      obj.memoryHeapCount = memoryHeapCount;
      std::copy(memoryHeaps, memoryHeaps + VK_MAX_MEMORY_HEAPS, obj.memoryHeaps);
      return obj;
   }

VkPhysicalDeviceMemoryProperties getPhysicalDeviceMemoryProperties(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceMemoryProperties pMemoryProperties; 
      vkGetPhysicalDeviceMemoryProperties(
          physicalDevice,
          &pMemoryProperties  );
      return pMemoryProperties; 
   }

struct VkDeviceQueueCreateInfoRAII {
   VkDeviceQueueCreateInfo nonRaiiObj;
    std::vector<float>                          vecQueuePriorities;
};

std::shared_ptr<VkDeviceQueueCreateInfoRAII> DeviceQueueCreateInfo(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    float* pQueuePriorities_in_array1, int pQueuePriorities_dim1)
   {
      std::shared_ptr<VkDeviceQueueCreateInfoRAII> raii_obj(new VkDeviceQueueCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.queueFamilyIndex = queueFamilyIndex;
      raii_obj->nonRaiiObj.queueCount = static_cast<uint32_t>(pQueuePriorities_dim1);
      raii_obj->vecQueuePriorities.assign(pQueuePriorities_in_array1, pQueuePriorities_in_array1 + pQueuePriorities_dim1);
      if ( raii_obj->vecQueuePriorities.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueuePriorities = &raii_obj->vecQueuePriorities[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueuePriorities = nullptr;
      }
      return raii_obj;
   }

struct VkDeviceCreateInfoRAII {
   VkDeviceCreateInfo nonRaiiObj;
    std::vector<VkDeviceQueueCreateInfo>        vecQueueCreateInfos;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
    std::shared_ptr<VkPhysicalDeviceFeatures>   pEnabledFeatures;
};

std::shared_ptr<VkDeviceCreateInfoRAII> DeviceCreateInfo(
    VkDeviceCreateFlags                         flags,
    const std::vector<VkDeviceQueueCreateInfo> &vecQueueCreateInfos,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames,
    const VkPhysicalDeviceFeatures *            pEnabledFeatures)
   {
      std::shared_ptr<VkDeviceCreateInfoRAII> raii_obj(new VkDeviceCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.queueCreateInfoCount = static_cast<uint32_t>(vecQueueCreateInfos.size());
      raii_obj->vecQueueCreateInfos = vecQueueCreateInfos;
      if ( raii_obj->vecQueueCreateInfos.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueCreateInfos = &raii_obj->vecQueueCreateInfos[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueCreateInfos = nullptr;
      }
      raii_obj->nonRaiiObj.enabledLayerCount = static_cast<uint32_t>(vecEnabledLayerNames.size());
      raii_obj->vecEnabledLayerNames = vecEnabledLayerNames;
      raii_obj->vecPtrEnabledLayerNames.resize(vecEnabledLayerNames.size());
      for (size_t i=0; i<vecEnabledLayerNames.size(); ++i) 
           raii_obj->vecPtrEnabledLayerNames[i] = raii_obj->vecEnabledLayerNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledLayerNames = &raii_obj->vecPtrEnabledLayerNames[0];
      raii_obj->nonRaiiObj.enabledExtensionCount = static_cast<uint32_t>(vecEnabledExtensionNames.size());
      raii_obj->vecEnabledExtensionNames = vecEnabledExtensionNames;
      raii_obj->vecPtrEnabledExtensionNames.resize(vecEnabledExtensionNames.size());
      for (size_t i=0; i<vecEnabledExtensionNames.size(); ++i) 
           raii_obj->vecPtrEnabledExtensionNames[i] = raii_obj->vecEnabledExtensionNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledExtensionNames = &raii_obj->vecPtrEnabledExtensionNames[0];
      raii_obj->nonRaiiObj.pEnabledFeatures = nullptr;
      if ( pEnabledFeatures ) 
      { 
          raii_obj->pEnabledFeatures.reset( new VkPhysicalDeviceFeatures );
          *raii_obj->pEnabledFeatures = *pEnabledFeatures;
          raii_obj->nonRaiiObj.pEnabledFeatures = raii_obj->pEnabledFeatures.get();
      } 
      return raii_obj;
   }

std::shared_ptr<VkDevice_T> createDevice(
        VkPhysicalDevice physicalDevice,
        const VkDeviceCreateInfo & pCreateInfo)
   {
      VkDevice hDevice; 
      V( vkCreateDevice(
          physicalDevice,
          &pCreateInfo,
          nullptr,
          &hDevice  ));
      return std::shared_ptr<VkDevice_T>(hDevice, 
              [=](VkDevice to_free) {vkDestroyDevice( to_free, nullptr);});
   }

VkExtensionProperties ExtensionProperties(
    char                                        extensionName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion)
   {
      VkExtensionProperties obj;
      std::copy(extensionName, extensionName + VK_MAX_EXTENSION_NAME_SIZE, obj.extensionName);
      obj.specVersion = specVersion;
      return obj;
   }

std::vector< VkExtensionProperties > enumerateInstanceExtensionProperties(
        const char* pLayerName)
   {
      std::vector<VkExtensionProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateInstanceExtensionProperties(
          pLayerName,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateInstanceExtensionProperties(
          pLayerName,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkExtensionProperties > enumerateDeviceExtensionProperties(
        VkPhysicalDevice physicalDevice,
        const char* pLayerName)
   {
      std::vector<VkExtensionProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateDeviceExtensionProperties(
          physicalDevice,
          pLayerName,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateDeviceExtensionProperties(
          physicalDevice,
          pLayerName,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

VkLayerProperties LayerProperties(
    char                                        layerName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion,
    uint32_t                                    implementationVersion,
    char                                        description[VK_MAX_DESCRIPTION_SIZE])
   {
      VkLayerProperties obj;
      std::copy(layerName, layerName + VK_MAX_EXTENSION_NAME_SIZE, obj.layerName);
      obj.specVersion = specVersion;
      obj.implementationVersion = implementationVersion;
      std::copy(description, description + VK_MAX_DESCRIPTION_SIZE, obj.description);
      return obj;
   }

std::vector< VkLayerProperties > enumerateInstanceLayerProperties(void)
   {
      std::vector<VkLayerProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateInstanceLayerProperties(
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateInstanceLayerProperties(
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkLayerProperties > enumerateDeviceLayerProperties(
        VkPhysicalDevice physicalDevice)
   {
      std::vector<VkLayerProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateDeviceLayerProperties(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateDeviceLayerProperties(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

VkQueue getDeviceQueue(
        VkDevice device,
        uint32_t queueFamilyIndex,
        uint32_t queueIndex)
   {
      VkQueue hQueue; 
      vkGetDeviceQueue(
          device,
          queueFamilyIndex,
          queueIndex,
          &hQueue  );
      return hQueue; 
   }

struct VkSubmitInfoRAII {
   VkSubmitInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkPipelineStageFlags>           vecWaitDstStageMask;
    std::vector<VkCommandBuffer>                vecCommandBuffers;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

std::shared_ptr<VkSubmitInfoRAII> SubmitInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkPipelineStageFlags> &   vecWaitDstStageMask,
    const std::vector<VkCommandBuffer> &        vecCommandBuffers,
    const std::vector<VkSemaphore> &            vecSignalSemaphores)
   {
      std::shared_ptr<VkSubmitInfoRAII> raii_obj(new VkSubmitInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->vecWaitDstStageMask = vecWaitDstStageMask;
      if ( raii_obj->vecWaitDstStageMask.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitDstStageMask = &raii_obj->vecWaitDstStageMask[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitDstStageMask = nullptr;
      }
      raii_obj->nonRaiiObj.commandBufferCount = static_cast<uint32_t>(vecCommandBuffers.size());
      raii_obj->vecCommandBuffers = vecCommandBuffers;
      if ( raii_obj->vecCommandBuffers.size() > 0)
      {
          raii_obj->nonRaiiObj.pCommandBuffers = &raii_obj->vecCommandBuffers[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCommandBuffers = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(vecSignalSemaphores.size());
      raii_obj->vecSignalSemaphores = vecSignalSemaphores;
      if ( raii_obj->vecSignalSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = &raii_obj->vecSignalSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = nullptr;
      }
      return raii_obj;
   }

void  queueSubmit(
        VkQueue queue,
        const std::vector<VkSubmitInfo> & pSubmits,
        VkFence fence)
   {
      V( vkQueueSubmit(
          queue,
          static_cast<uint32_t>(pSubmits.size()),
          &pSubmits[0],
          fence  ));
   }

void  queueWaitIdle(
        VkQueue queue)
   {
      V( vkQueueWaitIdle(
          queue  ));
   }

void  deviceWaitIdle(
        VkDevice device)
   {
      V( vkDeviceWaitIdle(
          device  ));
   }

VkMemoryAllocateInfo MemoryAllocateInfo(
    VkDeviceSize                                allocationSize,
    uint32_t                                    memoryTypeIndex)
   {
      VkMemoryAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.allocationSize = allocationSize;
      obj.memoryTypeIndex = memoryTypeIndex;
      return obj;
   }

std::shared_ptr<VkDeviceMemory_T> allocateMemory(
        VkDevice device,
        const VkMemoryAllocateInfo & pAllocateInfo)
   {
      VkDeviceMemory hMemory; 
      V( vkAllocateMemory(
          device,
          &pAllocateInfo,
          nullptr,
          &hMemory  ));
      return std::shared_ptr<VkDeviceMemory_T>(hMemory, 
              [=](VkDeviceMemory to_free) {vkFreeMemory(device, to_free, nullptr);});
   }

void  unmapMemory(
        VkDevice device,
        VkDeviceMemory memory)
   {
      vkUnmapMemory(
          device,
          memory  );
   }

VkMappedMemoryRange MappedMemoryRange(
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size)
   {
      VkMappedMemoryRange obj;
      obj.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
      obj.pNext = nullptr;
      obj.memory = memory;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

void  flushMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges)
   {
      V( vkFlushMappedMemoryRanges(
          device,
          static_cast<uint32_t>(pMemoryRanges.size()),
          &pMemoryRanges[0]  ));
   }

void  invalidateMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges)
   {
      V( vkInvalidateMappedMemoryRanges(
          device,
          static_cast<uint32_t>(pMemoryRanges.size()),
          &pMemoryRanges[0]  ));
   }

VkDeviceSize getDeviceMemoryCommitment(
        VkDevice device,
        VkDeviceMemory memory)
   {
      VkDeviceSize pCommittedMemoryInBytes; 
      vkGetDeviceMemoryCommitment(
          device,
          memory,
          &pCommittedMemoryInBytes  );
      return pCommittedMemoryInBytes; 
   }

void  bindBufferMemory(
        VkDevice device,
        VkBuffer buffer,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset)
   {
      V( vkBindBufferMemory(
          device,
          buffer,
          memory,
          memoryOffset  ));
   }

void  bindImageMemory(
        VkDevice device,
        VkImage image,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset)
   {
      V( vkBindImageMemory(
          device,
          image,
          memory,
          memoryOffset  ));
   }

VkMemoryRequirements MemoryRequirements(
    VkDeviceSize                                size,
    VkDeviceSize                                alignment,
    uint32_t                                    memoryTypeBits)
   {
      VkMemoryRequirements obj;
      obj.size = size;
      obj.alignment = alignment;
      obj.memoryTypeBits = memoryTypeBits;
      return obj;
   }

VkMemoryRequirements getBufferMemoryRequirements(
        VkDevice device,
        VkBuffer buffer)
   {
      VkMemoryRequirements pMemoryRequirements; 
      vkGetBufferMemoryRequirements(
          device,
          buffer,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkMemoryRequirements getImageMemoryRequirements(
        VkDevice device,
        VkImage image)
   {
      VkMemoryRequirements pMemoryRequirements; 
      vkGetImageMemoryRequirements(
          device,
          image,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkSparseImageFormatProperties SparseImageFormatProperties(
    VkImageAspectFlags                          aspectMask,
    VkExtent3D                                  imageGranularity,
    VkSparseImageFormatFlags                    flags)
   {
      VkSparseImageFormatProperties obj;
      obj.aspectMask = aspectMask;
      obj.imageGranularity = imageGranularity;
      obj.flags = flags;
      return obj;
   }

VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
    VkSparseImageFormatProperties               formatProperties,
    uint32_t                                    imageMipTailFirstLod,
    VkDeviceSize                                imageMipTailSize,
    VkDeviceSize                                imageMipTailOffset,
    VkDeviceSize                                imageMipTailStride)
   {
      VkSparseImageMemoryRequirements obj;
      obj.formatProperties = formatProperties;
      obj.imageMipTailFirstLod = imageMipTailFirstLod;
      obj.imageMipTailSize = imageMipTailSize;
      obj.imageMipTailOffset = imageMipTailOffset;
      obj.imageMipTailStride = imageMipTailStride;
      return obj;
   }

std::vector< VkSparseImageMemoryRequirements > getImageSparseMemoryRequirements(
        VkDevice device,
        VkImage image)
   {
      std::vector<VkSparseImageMemoryRequirements> vecpSparseMemoryRequirements; 
      uint32_t pSparseMemoryRequirementsCount; 
      vkGetImageSparseMemoryRequirements(
          device,
          image,
          &pSparseMemoryRequirementsCount,
          nullptr  );

      vecpSparseMemoryRequirements.resize(pSparseMemoryRequirementsCount); 

      vkGetImageSparseMemoryRequirements(
          device,
          image,
          &pSparseMemoryRequirementsCount,
          &vecpSparseMemoryRequirements[0]  );
      return vecpSparseMemoryRequirements; 
   }

std::vector< VkSparseImageFormatProperties > getPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkSampleCountFlagBits samples,
        VkImageUsageFlags usage,
        VkImageTiling tiling)
   {
      std::vector<VkSparseImageFormatProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      vkGetPhysicalDeviceSparseImageFormatProperties(
          physicalDevice,
          format,
          type,
          samples,
          usage,
          tiling,
          &pPropertiesCount,
          nullptr  );

      vecpProperties.resize(pPropertiesCount); 

      vkGetPhysicalDeviceSparseImageFormatProperties(
          physicalDevice,
          format,
          type,
          samples,
          usage,
          tiling,
          &pPropertiesCount,
          &vecpProperties[0]  );
      return vecpProperties; 
   }

VkSparseMemoryBind SparseMemoryBind(
    VkDeviceSize                                resourceOffset,
    VkDeviceSize                                size,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags)
   {
      VkSparseMemoryBind obj;
      obj.resourceOffset = resourceOffset;
      obj.size = size;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      obj.flags = flags;
      return obj;
   }

struct VkSparseBufferMemoryBindInfoRAII {
   VkSparseBufferMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> SparseBufferMemoryBindInfo(
    VkBuffer                                    buffer,
    const std::vector<VkSparseMemoryBind> &     vecBinds)
   {
      std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> raii_obj(new VkSparseBufferMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.buffer = buffer;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

struct VkSparseImageOpaqueMemoryBindInfoRAII {
   VkSparseImageOpaqueMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> SparseImageOpaqueMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseMemoryBind> &     vecBinds)
   {
      std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> raii_obj(new VkSparseImageOpaqueMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.image = image;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

VkImageSubresource ImageSubresource(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    arrayLayer)
   {
      VkImageSubresource obj;
      obj.aspectMask = aspectMask;
      obj.mipLevel = mipLevel;
      obj.arrayLayer = arrayLayer;
      return obj;
   }

VkOffset3D Offset3D(
    int32_t                                     x,
    int32_t                                     y,
    int32_t                                     z)
   {
      VkOffset3D obj;
      obj.x = x;
      obj.y = y;
      obj.z = z;
      return obj;
   }

VkSparseImageMemoryBind SparseImageMemoryBind(
    VkImageSubresource                          subresource,
    VkOffset3D                                  offset,
    VkExtent3D                                  extent,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags)
   {
      VkSparseImageMemoryBind obj;
      obj.subresource = subresource;
      obj.offset = offset;
      obj.extent = extent;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      obj.flags = flags;
      return obj;
   }

struct VkSparseImageMemoryBindInfoRAII {
   VkSparseImageMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseImageMemoryBind>        vecBinds;
};

std::shared_ptr<VkSparseImageMemoryBindInfoRAII> SparseImageMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseImageMemoryBind> &vecBinds)
   {
      std::shared_ptr<VkSparseImageMemoryBindInfoRAII> raii_obj(new VkSparseImageMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.image = image;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

struct VkBindSparseInfoRAII {
   VkBindSparseInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSparseBufferMemoryBindInfo>   vecBufferBinds;
    std::vector<VkSparseImageOpaqueMemoryBindInfo>vecImageOpaqueBinds;
    std::vector<VkSparseImageMemoryBindInfo>    vecImageBinds;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

std::shared_ptr<VkBindSparseInfoRAII> BindSparseInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSparseBufferMemoryBindInfo> &vecBufferBinds,
    const std::vector<VkSparseImageOpaqueMemoryBindInfo> &vecImageOpaqueBinds,
    const std::vector<VkSparseImageMemoryBindInfo> &vecImageBinds,
    const std::vector<VkSemaphore> &            vecSignalSemaphores)
   {
      std::shared_ptr<VkBindSparseInfoRAII> raii_obj(new VkBindSparseInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->nonRaiiObj.bufferBindCount = static_cast<uint32_t>(vecBufferBinds.size());
      raii_obj->vecBufferBinds = vecBufferBinds;
      if ( raii_obj->vecBufferBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBufferBinds = &raii_obj->vecBufferBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBufferBinds = nullptr;
      }
      raii_obj->nonRaiiObj.imageOpaqueBindCount = static_cast<uint32_t>(vecImageOpaqueBinds.size());
      raii_obj->vecImageOpaqueBinds = vecImageOpaqueBinds;
      if ( raii_obj->vecImageOpaqueBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageOpaqueBinds = &raii_obj->vecImageOpaqueBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageOpaqueBinds = nullptr;
      }
      raii_obj->nonRaiiObj.imageBindCount = static_cast<uint32_t>(vecImageBinds.size());
      raii_obj->vecImageBinds = vecImageBinds;
      if ( raii_obj->vecImageBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageBinds = &raii_obj->vecImageBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageBinds = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(vecSignalSemaphores.size());
      raii_obj->vecSignalSemaphores = vecSignalSemaphores;
      if ( raii_obj->vecSignalSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = &raii_obj->vecSignalSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = nullptr;
      }
      return raii_obj;
   }

void  queueBindSparse(
        VkQueue queue,
        const std::vector<VkBindSparseInfo> & pBindInfo,
        VkFence fence)
   {
      V( vkQueueBindSparse(
          queue,
          static_cast<uint32_t>(pBindInfo.size()),
          &pBindInfo[0],
          fence  ));
   }

VkFenceCreateInfo FenceCreateInfo(
    VkFenceCreateFlags                          flags)
   {
      VkFenceCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkFence_T> createFence(
        VkDevice device,
        const VkFenceCreateInfo & pCreateInfo)
   {
      VkFence hFence; 
      V( vkCreateFence(
          device,
          &pCreateInfo,
          nullptr,
          &hFence  ));
      return std::shared_ptr<VkFence_T>(hFence, 
              [=](VkFence to_free) {vkDestroyFence(device, to_free, nullptr);});
   }

void  resetFences(
        VkDevice device,
        const std::vector<VkFence> & pFences)
   {
      V( vkResetFences(
          device,
          static_cast<uint32_t>(pFences.size()),
          &pFences[0]  ));
   }

void  getFenceStatus(
        VkDevice device,
        VkFence fence)
   {
      V( vkGetFenceStatus(
          device,
          fence  ));
   }

void  waitForFences(
        VkDevice device,
        const std::vector<VkFence> & pFences,
        VkBool32 waitAll,
        uint64_t timeout)
   {
      V( vkWaitForFences(
          device,
          static_cast<uint32_t>(pFences.size()),
          &pFences[0],
          waitAll,
          timeout  ));
   }

VkSemaphoreCreateInfo SemaphoreCreateInfo(
    VkSemaphoreCreateFlags                      flags)
   {
      VkSemaphoreCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkSemaphore_T> createSemaphore(
        VkDevice device,
        const VkSemaphoreCreateInfo & pCreateInfo)
   {
      VkSemaphore hSemaphore; 
      V( vkCreateSemaphore(
          device,
          &pCreateInfo,
          nullptr,
          &hSemaphore  ));
      return std::shared_ptr<VkSemaphore_T>(hSemaphore, 
              [=](VkSemaphore to_free) {vkDestroySemaphore(device, to_free, nullptr);});
   }

VkEventCreateInfo EventCreateInfo(
    VkEventCreateFlags                          flags)
   {
      VkEventCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkEvent_T> createEvent(
        VkDevice device,
        const VkEventCreateInfo & pCreateInfo)
   {
      VkEvent hEvent; 
      V( vkCreateEvent(
          device,
          &pCreateInfo,
          nullptr,
          &hEvent  ));
      return std::shared_ptr<VkEvent_T>(hEvent, 
              [=](VkEvent to_free) {vkDestroyEvent(device, to_free, nullptr);});
   }

void  getEventStatus(
        VkDevice device,
        VkEvent event)
   {
      V( vkGetEventStatus(
          device,
          event  ));
   }

void  setEvent(
        VkDevice device,
        VkEvent event)
   {
      V( vkSetEvent(
          device,
          event  ));
   }

void  resetEvent(
        VkDevice device,
        VkEvent event)
   {
      V( vkResetEvent(
          device,
          event  ));
   }

VkQueryPoolCreateInfo QueryPoolCreateInfo(
    VkQueryPoolCreateFlags                      flags,
    VkQueryType                                 queryType,
    uint32_t                                    queryCount,
    VkQueryPipelineStatisticFlags               pipelineStatistics)
   {
      VkQueryPoolCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.queryType = queryType;
      obj.queryCount = queryCount;
      obj.pipelineStatistics = pipelineStatistics;
      return obj;
   }

std::shared_ptr<VkQueryPool_T> createQueryPool(
        VkDevice device,
        const VkQueryPoolCreateInfo & pCreateInfo)
   {
      VkQueryPool hQueryPool; 
      V( vkCreateQueryPool(
          device,
          &pCreateInfo,
          nullptr,
          &hQueryPool  ));
      return std::shared_ptr<VkQueryPool_T>(hQueryPool, 
              [=](VkQueryPool to_free) {vkDestroyQueryPool(device, to_free, nullptr);});
   }

void  getQueryPoolResults(
        VkDevice device,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        size_t dataSize,
        VkDeviceSize stride,
        VkQueryResultFlags flags)
   {
      V( vkGetQueryPoolResults(
          device,
          queryPool,
          firstQuery,
          queryCount,
          dataSize,
          nullptr,
          stride,
          flags  ));
   }

struct VkBufferCreateInfoRAII {
   VkBufferCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkBufferCreateInfoRAII> BufferCreateInfo(
    VkBufferCreateFlags                         flags,
    VkDeviceSize                                size,
    VkBufferUsageFlags                          usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1)
   {
      std::shared_ptr<VkBufferCreateInfoRAII> raii_obj(new VkBufferCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.size = size;
      raii_obj->nonRaiiObj.usage = usage;
      raii_obj->nonRaiiObj.sharingMode = sharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkBuffer_T> createBuffer(
        VkDevice device,
        const VkBufferCreateInfo & pCreateInfo)
   {
      VkBuffer hBuffer; 
      V( vkCreateBuffer(
          device,
          &pCreateInfo,
          nullptr,
          &hBuffer  ));
      return std::shared_ptr<VkBuffer_T>(hBuffer, 
              [=](VkBuffer to_free) {vkDestroyBuffer(device, to_free, nullptr);});
   }

VkBufferViewCreateInfo BufferViewCreateInfo(
    VkBufferViewCreateFlags                     flags,
    VkBuffer                                    buffer,
    VkFormat                                    format,
    VkDeviceSize                                offset,
    VkDeviceSize                                range)
   {
      VkBufferViewCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.buffer = buffer;
      obj.format = format;
      obj.offset = offset;
      obj.range = range;
      return obj;
   }

std::shared_ptr<VkBufferView_T> createBufferView(
        VkDevice device,
        const VkBufferViewCreateInfo & pCreateInfo)
   {
      VkBufferView hView; 
      V( vkCreateBufferView(
          device,
          &pCreateInfo,
          nullptr,
          &hView  ));
      return std::shared_ptr<VkBufferView_T>(hView, 
              [=](VkBufferView to_free) {vkDestroyBufferView(device, to_free, nullptr);});
   }

struct VkImageCreateInfoRAII {
   VkImageCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkImageCreateInfoRAII> ImageCreateInfo(
    VkImageCreateFlags                          flags,
    VkImageType                                 imageType,
    VkFormat                                    format,
    VkExtent3D                                  extent,
    uint32_t                                    mipLevels,
    uint32_t                                    arrayLayers,
    VkSampleCountFlagBits                       samples,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkImageLayout                               initialLayout)
   {
      std::shared_ptr<VkImageCreateInfoRAII> raii_obj(new VkImageCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.imageType = imageType;
      raii_obj->nonRaiiObj.format = format;
      raii_obj->nonRaiiObj.extent = extent;
      raii_obj->nonRaiiObj.mipLevels = mipLevels;
      raii_obj->nonRaiiObj.arrayLayers = arrayLayers;
      raii_obj->nonRaiiObj.samples = samples;
      raii_obj->nonRaiiObj.tiling = tiling;
      raii_obj->nonRaiiObj.usage = usage;
      raii_obj->nonRaiiObj.sharingMode = sharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      raii_obj->nonRaiiObj.initialLayout = initialLayout;
      return raii_obj;
   }

std::shared_ptr<VkImage_T> createImage(
        VkDevice device,
        const VkImageCreateInfo & pCreateInfo)
   {
      VkImage hImage; 
      V( vkCreateImage(
          device,
          &pCreateInfo,
          nullptr,
          &hImage  ));
      return std::shared_ptr<VkImage_T>(hImage, 
              [=](VkImage to_free) {vkDestroyImage(device, to_free, nullptr);});
   }

VkSubresourceLayout SubresourceLayout(
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkDeviceSize                                rowPitch,
    VkDeviceSize                                arrayPitch,
    VkDeviceSize                                depthPitch)
   {
      VkSubresourceLayout obj;
      obj.offset = offset;
      obj.size = size;
      obj.rowPitch = rowPitch;
      obj.arrayPitch = arrayPitch;
      obj.depthPitch = depthPitch;
      return obj;
   }

VkSubresourceLayout getImageSubresourceLayout(
        VkDevice device,
        VkImage image,
        const VkImageSubresource & pSubresource)
   {
      VkSubresourceLayout pLayout; 
      vkGetImageSubresourceLayout(
          device,
          image,
          &pSubresource,
          &pLayout  );
      return pLayout; 
   }

VkComponentMapping ComponentMapping(
    VkComponentSwizzle                          r,
    VkComponentSwizzle                          g,
    VkComponentSwizzle                          b,
    VkComponentSwizzle                          a)
   {
      VkComponentMapping obj;
      obj.r = r;
      obj.g = g;
      obj.b = b;
      obj.a = a;
      return obj;
   }

VkImageSubresourceRange ImageSubresourceRange(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    baseMipLevel,
    uint32_t                                    levelCount,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkImageSubresourceRange obj;
      obj.aspectMask = aspectMask;
      obj.baseMipLevel = baseMipLevel;
      obj.levelCount = levelCount;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

VkImageViewCreateInfo ImageViewCreateInfo(
    VkImageViewCreateFlags                      flags,
    VkImage                                     image,
    VkImageViewType                             viewType,
    VkFormat                                    format,
    VkComponentMapping                          components,
    VkImageSubresourceRange                     subresourceRange)
   {
      VkImageViewCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.image = image;
      obj.viewType = viewType;
      obj.format = format;
      obj.components = components;
      obj.subresourceRange = subresourceRange;
      return obj;
   }

std::shared_ptr<VkImageView_T> createImageView(
        VkDevice device,
        const VkImageViewCreateInfo & pCreateInfo)
   {
      VkImageView hView; 
      V( vkCreateImageView(
          device,
          &pCreateInfo,
          nullptr,
          &hView  ));
      return std::shared_ptr<VkImageView_T>(hView, 
              [=](VkImageView to_free) {vkDestroyImageView(device, to_free, nullptr);});
   }

VkShaderModuleCreateInfo ShaderModuleCreateInfo(
    VkShaderModuleCreateFlags                   flags,
    size_t                                      codeSize,
    const uint32_t*                             pCode)
   {
      VkShaderModuleCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.codeSize = codeSize * sizeof(unsigned int);
      obj.pCode = pCode;
      return obj;
   }

std::shared_ptr<VkShaderModule_T> createShaderModule(
        VkDevice device,
        const VkShaderModuleCreateInfo & pCreateInfo)
   {
      VkShaderModule hShaderModule; 
      V( vkCreateShaderModule(
          device,
          &pCreateInfo,
          nullptr,
          &hShaderModule  ));
      return std::shared_ptr<VkShaderModule_T>(hShaderModule, 
              [=](VkShaderModule to_free) {vkDestroyShaderModule(device, to_free, nullptr);});
   }

VkPipelineCacheCreateInfo PipelineCacheCreateInfo(
    VkPipelineCacheCreateFlags                  flags,
    size_t                                      initialDataSize)
   {
      VkPipelineCacheCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.initialDataSize = initialDataSize;
      obj.pInitialData = nullptr;
      return obj;
   }

std::shared_ptr<VkPipelineCache_T> createPipelineCache(
        VkDevice device,
        const VkPipelineCacheCreateInfo & pCreateInfo)
   {
      VkPipelineCache hPipelineCache; 
      V( vkCreatePipelineCache(
          device,
          &pCreateInfo,
          nullptr,
          &hPipelineCache  ));
      return std::shared_ptr<VkPipelineCache_T>(hPipelineCache, 
              [=](VkPipelineCache to_free) {vkDestroyPipelineCache(device, to_free, nullptr);});
   }

size_t getPipelineCacheData(
        VkDevice device,
        VkPipelineCache pipelineCache)
   {
      size_t pDataSize; 
      V( vkGetPipelineCacheData(
          device,
          pipelineCache,
          &pDataSize,
          nullptr  ));
      return pDataSize; 
   }

void  mergePipelineCaches(
        VkDevice device,
        VkPipelineCache dstCache,
        const std::vector<VkPipelineCache> & pSrcCaches)
   {
      V( vkMergePipelineCaches(
          device,
          dstCache,
          static_cast<uint32_t>(pSrcCaches.size()),
          &pSrcCaches[0]  ));
   }

VkSpecializationMapEntry SpecializationMapEntry(
    uint32_t                                    constantID,
    uint32_t                                    offset,
    size_t                                      size)
   {
      VkSpecializationMapEntry obj;
      obj.constantID = constantID;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

struct VkSpecializationInfoRAII {
   VkSpecializationInfo nonRaiiObj;
    std::vector<VkSpecializationMapEntry>       vecMapEntries;
};

std::shared_ptr<VkSpecializationInfoRAII> SpecializationInfo(
    const std::vector<VkSpecializationMapEntry> &vecMapEntries,
    size_t                                      dataSize)
   {
      std::shared_ptr<VkSpecializationInfoRAII> raii_obj(new VkSpecializationInfoRAII);
      raii_obj->nonRaiiObj.mapEntryCount = static_cast<uint32_t>(vecMapEntries.size());
      raii_obj->vecMapEntries = vecMapEntries;
      if ( raii_obj->vecMapEntries.size() > 0)
      {
          raii_obj->nonRaiiObj.pMapEntries = &raii_obj->vecMapEntries[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pMapEntries = nullptr;
      }
      raii_obj->nonRaiiObj.dataSize = dataSize;
      raii_obj->nonRaiiObj.pData = nullptr;
      return raii_obj;
   }

struct VkPipelineShaderStageCreateInfoRAII {
   VkPipelineShaderStageCreateInfo nonRaiiObj;
    std::string                                 strName;
    std::shared_ptr<VkSpecializationInfoRAII>   pSpecializationInfo;
};

std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> PipelineShaderStageCreateInfo(
    VkPipelineShaderStageCreateFlags            flags,
    VkShaderStageFlagBits                       stage,
    VkShaderModule                              module,
    const std::string &                         strName,
    const std::shared_ptr<VkSpecializationInfoRAII> &pSpecializationInfo)
   {
      std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> raii_obj(new VkPipelineShaderStageCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.stage = stage;
      raii_obj->nonRaiiObj.module = module;
      raii_obj->strName = strName;
      raii_obj->nonRaiiObj.pName = &raii_obj->strName[0];
      raii_obj->pSpecializationInfo = pSpecializationInfo;
      if ( pSpecializationInfo ) 
      {
          raii_obj->nonRaiiObj.pSpecializationInfo = &(pSpecializationInfo->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pSpecializationInfo = nullptr;
      }
      return raii_obj;
   }

VkVertexInputBindingDescription VertexInputBindingDescription(
    uint32_t                                    binding,
    uint32_t                                    stride,
    VkVertexInputRate                           inputRate)
   {
      VkVertexInputBindingDescription obj;
      obj.binding = binding;
      obj.stride = stride;
      obj.inputRate = inputRate;
      return obj;
   }

VkVertexInputAttributeDescription VertexInputAttributeDescription(
    uint32_t                                    location,
    uint32_t                                    binding,
    VkFormat                                    format,
    uint32_t                                    offset)
   {
      VkVertexInputAttributeDescription obj;
      obj.location = location;
      obj.binding = binding;
      obj.format = format;
      obj.offset = offset;
      return obj;
   }

struct VkPipelineVertexInputStateCreateInfoRAII {
   VkPipelineVertexInputStateCreateInfo nonRaiiObj;
    std::vector<VkVertexInputBindingDescription>vecVertexBindingDescriptions;
    std::vector<VkVertexInputAttributeDescription>vecVertexAttributeDescriptions;
};

std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> PipelineVertexInputStateCreateInfo(
    VkPipelineVertexInputStateCreateFlags       flags,
    const std::vector<VkVertexInputBindingDescription> &vecVertexBindingDescriptions,
    const std::vector<VkVertexInputAttributeDescription> &vecVertexAttributeDescriptions)
   {
      std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> raii_obj(new VkPipelineVertexInputStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.vertexBindingDescriptionCount = static_cast<uint32_t>(vecVertexBindingDescriptions.size());
      raii_obj->vecVertexBindingDescriptions = vecVertexBindingDescriptions;
      if ( raii_obj->vecVertexBindingDescriptions.size() > 0)
      {
          raii_obj->nonRaiiObj.pVertexBindingDescriptions = &raii_obj->vecVertexBindingDescriptions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexBindingDescriptions = nullptr;
      }
      raii_obj->nonRaiiObj.vertexAttributeDescriptionCount = static_cast<uint32_t>(vecVertexAttributeDescriptions.size());
      raii_obj->vecVertexAttributeDescriptions = vecVertexAttributeDescriptions;
      if ( raii_obj->vecVertexAttributeDescriptions.size() > 0)
      {
          raii_obj->nonRaiiObj.pVertexAttributeDescriptions = &raii_obj->vecVertexAttributeDescriptions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexAttributeDescriptions = nullptr;
      }
      return raii_obj;
   }

VkPipelineInputAssemblyStateCreateInfo PipelineInputAssemblyStateCreateInfo(
    VkPipelineInputAssemblyStateCreateFlags     flags,
    VkPrimitiveTopology                         topology,
    VkBool32                                    primitiveRestartEnable)
   {
      VkPipelineInputAssemblyStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.topology = topology;
      obj.primitiveRestartEnable = primitiveRestartEnable;
      return obj;
   }

VkPipelineTessellationStateCreateInfo PipelineTessellationStateCreateInfo(
    VkPipelineTessellationStateCreateFlags      flags,
    uint32_t                                    patchControlPoints)
   {
      VkPipelineTessellationStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.patchControlPoints = patchControlPoints;
      return obj;
   }

VkViewport Viewport(
    float                                       x,
    float                                       y,
    float                                       width,
    float                                       height,
    float                                       minDepth,
    float                                       maxDepth)
   {
      VkViewport obj;
      obj.x = x;
      obj.y = y;
      obj.width = width;
      obj.height = height;
      obj.minDepth = minDepth;
      obj.maxDepth = maxDepth;
      return obj;
   }

VkOffset2D Offset2D(
    int32_t                                     x,
    int32_t                                     y)
   {
      VkOffset2D obj;
      obj.x = x;
      obj.y = y;
      return obj;
   }

VkExtent2D Extent2D(
    uint32_t                                    width,
    uint32_t                                    height)
   {
      VkExtent2D obj;
      obj.width = width;
      obj.height = height;
      return obj;
   }

VkRect2D Rect2D(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent)
   {
      VkRect2D obj;
      obj.offset = offset;
      obj.extent = extent;
      return obj;
   }

struct VkPipelineViewportStateCreateInfoRAII {
   VkPipelineViewportStateCreateInfo nonRaiiObj;
    std::vector<VkViewport>                     vecViewports;
    std::vector<VkRect2D>                       vecScissors;
};

std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> PipelineViewportStateCreateInfo(
    VkPipelineViewportStateCreateFlags          flags,
    const std::vector<VkViewport> &             vecViewports,
    const std::vector<VkRect2D> &               vecScissors)
   {
      std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> raii_obj(new VkPipelineViewportStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.viewportCount = static_cast<uint32_t>(vecViewports.size());
      raii_obj->vecViewports = vecViewports;
      if ( raii_obj->vecViewports.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewports = &raii_obj->vecViewports[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewports = nullptr;
      }
      raii_obj->nonRaiiObj.scissorCount = static_cast<uint32_t>(vecScissors.size());
      raii_obj->vecScissors = vecScissors;
      if ( raii_obj->vecScissors.size() > 0)
      {
          raii_obj->nonRaiiObj.pScissors = &raii_obj->vecScissors[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pScissors = nullptr;
      }
      return raii_obj;
   }

VkPipelineRasterizationStateCreateInfo PipelineRasterizationStateCreateInfo(
    VkPipelineRasterizationStateCreateFlags     flags,
    VkBool32                                    depthClampEnable,
    VkBool32                                    rasterizerDiscardEnable,
    VkPolygonMode                               polygonMode,
    VkCullModeFlags                             cullMode,
    VkFrontFace                                 frontFace,
    VkBool32                                    depthBiasEnable,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor,
    float                                       lineWidth)
   {
      VkPipelineRasterizationStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.depthClampEnable = depthClampEnable;
      obj.rasterizerDiscardEnable = rasterizerDiscardEnable;
      obj.polygonMode = polygonMode;
      obj.cullMode = cullMode;
      obj.frontFace = frontFace;
      obj.depthBiasEnable = depthBiasEnable;
      obj.depthBiasConstantFactor = depthBiasConstantFactor;
      obj.depthBiasClamp = depthBiasClamp;
      obj.depthBiasSlopeFactor = depthBiasSlopeFactor;
      obj.lineWidth = lineWidth;
      return obj;
   }

VkPipelineMultisampleStateCreateInfo PipelineMultisampleStateCreateInfo(
    VkPipelineMultisampleStateCreateFlags       flags,
    VkSampleCountFlagBits                       rasterizationSamples,
    VkBool32                                    sampleShadingEnable,
    float                                       minSampleShading,
    const VkSampleMask*                         pSampleMask,
    VkBool32                                    alphaToCoverageEnable,
    VkBool32                                    alphaToOneEnable)
   {
      VkPipelineMultisampleStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.rasterizationSamples = rasterizationSamples;
      obj.sampleShadingEnable = sampleShadingEnable;
      obj.minSampleShading = minSampleShading;
      obj.pSampleMask = pSampleMask;
      obj.alphaToCoverageEnable = alphaToCoverageEnable;
      obj.alphaToOneEnable = alphaToOneEnable;
      return obj;
   }

VkStencilOpState StencilOpState(
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp,
    uint32_t                                    compareMask,
    uint32_t                                    writeMask,
    uint32_t                                    reference)
   {
      VkStencilOpState obj;
      obj.failOp = failOp;
      obj.passOp = passOp;
      obj.depthFailOp = depthFailOp;
      obj.compareOp = compareOp;
      obj.compareMask = compareMask;
      obj.writeMask = writeMask;
      obj.reference = reference;
      return obj;
   }

VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilStateCreateInfo(
    VkPipelineDepthStencilStateCreateFlags      flags,
    VkBool32                                    depthTestEnable,
    VkBool32                                    depthWriteEnable,
    VkCompareOp                                 depthCompareOp,
    VkBool32                                    depthBoundsTestEnable,
    VkBool32                                    stencilTestEnable,
    VkStencilOpState                            front,
    VkStencilOpState                            back,
    float                                       minDepthBounds,
    float                                       maxDepthBounds)
   {
      VkPipelineDepthStencilStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.depthTestEnable = depthTestEnable;
      obj.depthWriteEnable = depthWriteEnable;
      obj.depthCompareOp = depthCompareOp;
      obj.depthBoundsTestEnable = depthBoundsTestEnable;
      obj.stencilTestEnable = stencilTestEnable;
      obj.front = front;
      obj.back = back;
      obj.minDepthBounds = minDepthBounds;
      obj.maxDepthBounds = maxDepthBounds;
      return obj;
   }

VkPipelineColorBlendAttachmentState PipelineColorBlendAttachmentState(
    VkBool32                                    blendEnable,
    VkBlendFactor                               srcColorBlendFactor,
    VkBlendFactor                               dstColorBlendFactor,
    VkBlendOp                                   colorBlendOp,
    VkBlendFactor                               srcAlphaBlendFactor,
    VkBlendFactor                               dstAlphaBlendFactor,
    VkBlendOp                                   alphaBlendOp,
    VkColorComponentFlags                       colorWriteMask)
   {
      VkPipelineColorBlendAttachmentState obj;
      obj.blendEnable = blendEnable;
      obj.srcColorBlendFactor = srcColorBlendFactor;
      obj.dstColorBlendFactor = dstColorBlendFactor;
      obj.colorBlendOp = colorBlendOp;
      obj.srcAlphaBlendFactor = srcAlphaBlendFactor;
      obj.dstAlphaBlendFactor = dstAlphaBlendFactor;
      obj.alphaBlendOp = alphaBlendOp;
      obj.colorWriteMask = colorWriteMask;
      return obj;
   }

struct VkPipelineColorBlendStateCreateInfoRAII {
   VkPipelineColorBlendStateCreateInfo nonRaiiObj;
    std::vector<VkPipelineColorBlendAttachmentState>vecAttachments;
};

std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> PipelineColorBlendStateCreateInfo(
    VkPipelineColorBlendStateCreateFlags        flags,
    VkBool32                                    logicOpEnable,
    VkLogicOp                                   logicOp,
    const std::vector<VkPipelineColorBlendAttachmentState> &vecAttachments,
    float                                       blendConstants[4])
   {
      std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> raii_obj(new VkPipelineColorBlendStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.logicOpEnable = logicOpEnable;
      raii_obj->nonRaiiObj.logicOp = logicOp;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      std::copy(blendConstants, blendConstants + 4, raii_obj->nonRaiiObj.blendConstants);
      return raii_obj;
   }

struct VkPipelineDynamicStateCreateInfoRAII {
   VkPipelineDynamicStateCreateInfo nonRaiiObj;
    std::vector<VkDynamicState>                 vecDynamicStates;
};

std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> PipelineDynamicStateCreateInfo(
    VkPipelineDynamicStateCreateFlags           flags,
    const std::vector<VkDynamicState> &         vecDynamicStates)
   {
      std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> raii_obj(new VkPipelineDynamicStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.dynamicStateCount = static_cast<uint32_t>(vecDynamicStates.size());
      raii_obj->vecDynamicStates = vecDynamicStates;
      if ( raii_obj->vecDynamicStates.size() > 0)
      {
          raii_obj->nonRaiiObj.pDynamicStates = &raii_obj->vecDynamicStates[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDynamicStates = nullptr;
      }
      return raii_obj;
   }

struct VkGraphicsPipelineCreateInfoRAII {
   VkGraphicsPipelineCreateInfo nonRaiiObj;
    std::vector<VkPipelineShaderStageCreateInfo>vecStages;
    std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>pVertexInputState;
    std::shared_ptr<VkPipelineInputAssemblyStateCreateInfo>pInputAssemblyState;
    std::shared_ptr<VkPipelineTessellationStateCreateInfo>pTessellationState;
    std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>pViewportState;
    std::shared_ptr<VkPipelineRasterizationStateCreateInfo>pRasterizationState;
    std::shared_ptr<VkPipelineMultisampleStateCreateInfo>pMultisampleState;
    std::shared_ptr<VkPipelineDepthStencilStateCreateInfo>pDepthStencilState;
    std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>pColorBlendState;
    std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>pDynamicState;
};

std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> GraphicsPipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    const std::vector<VkPipelineShaderStageCreateInfo> &vecStages,
    const std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> &pVertexInputState,
    const VkPipelineInputAssemblyStateCreateInfo *pInputAssemblyState,
    const VkPipelineTessellationStateCreateInfo *pTessellationState,
    const std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> &pViewportState,
    const VkPipelineRasterizationStateCreateInfo *pRasterizationState,
    const VkPipelineMultisampleStateCreateInfo *pMultisampleState,
    const VkPipelineDepthStencilStateCreateInfo *pDepthStencilState,
    const std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> &pColorBlendState,
    const std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> &pDynamicState,
    VkPipelineLayout                            layout,
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex)
   {
      std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> raii_obj(new VkGraphicsPipelineCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.stageCount = static_cast<uint32_t>(vecStages.size());
      raii_obj->vecStages = vecStages;
      if ( raii_obj->vecStages.size() > 0)
      {
          raii_obj->nonRaiiObj.pStages = &raii_obj->vecStages[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pStages = nullptr;
      }
      raii_obj->pVertexInputState = pVertexInputState;
      if ( pVertexInputState ) 
      {
          raii_obj->nonRaiiObj.pVertexInputState = &(pVertexInputState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexInputState = nullptr;
      }
      raii_obj->nonRaiiObj.pInputAssemblyState = nullptr;
      if ( pInputAssemblyState ) 
      { 
          raii_obj->pInputAssemblyState.reset( new VkPipelineInputAssemblyStateCreateInfo );
          *raii_obj->pInputAssemblyState = *pInputAssemblyState;
          raii_obj->nonRaiiObj.pInputAssemblyState = raii_obj->pInputAssemblyState.get();
      } 
      raii_obj->nonRaiiObj.pTessellationState = nullptr;
      if ( pTessellationState ) 
      { 
          raii_obj->pTessellationState.reset( new VkPipelineTessellationStateCreateInfo );
          *raii_obj->pTessellationState = *pTessellationState;
          raii_obj->nonRaiiObj.pTessellationState = raii_obj->pTessellationState.get();
      } 
      raii_obj->pViewportState = pViewportState;
      if ( pViewportState ) 
      {
          raii_obj->nonRaiiObj.pViewportState = &(pViewportState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pViewportState = nullptr;
      }
      raii_obj->nonRaiiObj.pRasterizationState = nullptr;
      if ( pRasterizationState ) 
      { 
          raii_obj->pRasterizationState.reset( new VkPipelineRasterizationStateCreateInfo );
          *raii_obj->pRasterizationState = *pRasterizationState;
          raii_obj->nonRaiiObj.pRasterizationState = raii_obj->pRasterizationState.get();
      } 
      raii_obj->nonRaiiObj.pMultisampleState = nullptr;
      if ( pMultisampleState ) 
      { 
          raii_obj->pMultisampleState.reset( new VkPipelineMultisampleStateCreateInfo );
          *raii_obj->pMultisampleState = *pMultisampleState;
          raii_obj->nonRaiiObj.pMultisampleState = raii_obj->pMultisampleState.get();
      } 
      raii_obj->nonRaiiObj.pDepthStencilState = nullptr;
      if ( pDepthStencilState ) 
      { 
          raii_obj->pDepthStencilState.reset( new VkPipelineDepthStencilStateCreateInfo );
          *raii_obj->pDepthStencilState = *pDepthStencilState;
          raii_obj->nonRaiiObj.pDepthStencilState = raii_obj->pDepthStencilState.get();
      } 
      raii_obj->pColorBlendState = pColorBlendState;
      if ( pColorBlendState ) 
      {
          raii_obj->nonRaiiObj.pColorBlendState = &(pColorBlendState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pColorBlendState = nullptr;
      }
      raii_obj->pDynamicState = pDynamicState;
      if ( pDynamicState ) 
      {
          raii_obj->nonRaiiObj.pDynamicState = &(pDynamicState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pDynamicState = nullptr;
      }
      raii_obj->nonRaiiObj.layout = layout;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.subpass = subpass;
      raii_obj->nonRaiiObj.basePipelineHandle = basePipelineHandle;
      raii_obj->nonRaiiObj.basePipelineIndex = basePipelineIndex;
      return raii_obj;
   }

std::vector< std::shared_ptr<VkPipeline_T> > createGraphicsPipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkGraphicsPipelineCreateInfo> & pCreateInfos)
   {
      std::vector<VkPipeline> vecpPipelines( pCreateInfos.size(), nullptr ); 
      V( vkCreateGraphicsPipelines(
          device,
          pipelineCache,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpPipelines[0]  ));
      std::vector< std::shared_ptr<VkPipeline_T> > retval; 
      retval.reserve(vecpPipelines.size()); 
      for (auto allocated_handle : vecpPipelines ) 
      {
          retval.push_back(std::shared_ptr<VkPipeline_T>(allocated_handle, 
              [=](VkPipeline to_free) {vkDestroyPipeline(device, to_free, nullptr);}));
      }
      return retval; 
   }

VkComputePipelineCreateInfo ComputePipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    VkPipelineShaderStageCreateInfo             stage,
    VkPipelineLayout                            layout,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex)
   {
      VkComputePipelineCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.stage = stage;
      obj.layout = layout;
      obj.basePipelineHandle = basePipelineHandle;
      obj.basePipelineIndex = basePipelineIndex;
      return obj;
   }

std::vector< std::shared_ptr<VkPipeline_T> > createComputePipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkComputePipelineCreateInfo> & pCreateInfos)
   {
      std::vector<VkPipeline> vecpPipelines( pCreateInfos.size(), nullptr ); 
      V( vkCreateComputePipelines(
          device,
          pipelineCache,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpPipelines[0]  ));
      std::vector< std::shared_ptr<VkPipeline_T> > retval; 
      retval.reserve(vecpPipelines.size()); 
      for (auto allocated_handle : vecpPipelines ) 
      {
          retval.push_back(std::shared_ptr<VkPipeline_T>(allocated_handle, 
              [=](VkPipeline to_free) {vkDestroyPipeline(device, to_free, nullptr);}));
      }
      return retval; 
   }

VkPushConstantRange PushConstantRange(
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size)
   {
      VkPushConstantRange obj;
      obj.stageFlags = stageFlags;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

struct VkPipelineLayoutCreateInfoRAII {
   VkPipelineLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
    std::vector<VkPushConstantRange>            vecPushConstantRanges;
};

std::shared_ptr<VkPipelineLayoutCreateInfoRAII> PipelineLayoutCreateInfo(
    VkPipelineLayoutCreateFlags                 flags,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts,
    const std::vector<VkPushConstantRange> &    vecPushConstantRanges)
   {
      std::shared_ptr<VkPipelineLayoutCreateInfoRAII> raii_obj(new VkPipelineLayoutCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.setLayoutCount = static_cast<uint32_t>(vecSetLayouts.size());
      raii_obj->vecSetLayouts = vecSetLayouts;
      if ( raii_obj->vecSetLayouts.size() > 0)
      {
          raii_obj->nonRaiiObj.pSetLayouts = &raii_obj->vecSetLayouts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSetLayouts = nullptr;
      }
      raii_obj->nonRaiiObj.pushConstantRangeCount = static_cast<uint32_t>(vecPushConstantRanges.size());
      raii_obj->vecPushConstantRanges = vecPushConstantRanges;
      if ( raii_obj->vecPushConstantRanges.size() > 0)
      {
          raii_obj->nonRaiiObj.pPushConstantRanges = &raii_obj->vecPushConstantRanges[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPushConstantRanges = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkPipelineLayout_T> createPipelineLayout(
        VkDevice device,
        const VkPipelineLayoutCreateInfo & pCreateInfo)
   {
      VkPipelineLayout hPipelineLayout; 
      V( vkCreatePipelineLayout(
          device,
          &pCreateInfo,
          nullptr,
          &hPipelineLayout  ));
      return std::shared_ptr<VkPipelineLayout_T>(hPipelineLayout, 
              [=](VkPipelineLayout to_free) {vkDestroyPipelineLayout(device, to_free, nullptr);});
   }

VkSamplerCreateInfo SamplerCreateInfo(
    VkSamplerCreateFlags                        flags,
    VkFilter                                    magFilter,
    VkFilter                                    minFilter,
    VkSamplerMipmapMode                         mipmapMode,
    VkSamplerAddressMode                        addressModeU,
    VkSamplerAddressMode                        addressModeV,
    VkSamplerAddressMode                        addressModeW,
    float                                       mipLodBias,
    VkBool32                                    anisotropyEnable,
    float                                       maxAnisotropy,
    VkBool32                                    compareEnable,
    VkCompareOp                                 compareOp,
    float                                       minLod,
    float                                       maxLod,
    VkBorderColor                               borderColor,
    VkBool32                                    unnormalizedCoordinates)
   {
      VkSamplerCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.magFilter = magFilter;
      obj.minFilter = minFilter;
      obj.mipmapMode = mipmapMode;
      obj.addressModeU = addressModeU;
      obj.addressModeV = addressModeV;
      obj.addressModeW = addressModeW;
      obj.mipLodBias = mipLodBias;
      obj.anisotropyEnable = anisotropyEnable;
      obj.maxAnisotropy = maxAnisotropy;
      obj.compareEnable = compareEnable;
      obj.compareOp = compareOp;
      obj.minLod = minLod;
      obj.maxLod = maxLod;
      obj.borderColor = borderColor;
      obj.unnormalizedCoordinates = unnormalizedCoordinates;
      return obj;
   }

std::shared_ptr<VkSampler_T> createSampler(
        VkDevice device,
        const VkSamplerCreateInfo & pCreateInfo)
   {
      VkSampler hSampler; 
      V( vkCreateSampler(
          device,
          &pCreateInfo,
          nullptr,
          &hSampler  ));
      return std::shared_ptr<VkSampler_T>(hSampler, 
              [=](VkSampler to_free) {vkDestroySampler(device, to_free, nullptr);});
   }

struct VkDescriptorSetLayoutBindingRAII {
   VkDescriptorSetLayoutBinding nonRaiiObj;
    std::vector<VkSampler>                      vecImmutableSamplers;
};

std::shared_ptr<VkDescriptorSetLayoutBindingRAII> DescriptorSetLayoutBinding(
    uint32_t                                    binding,
    VkDescriptorType                            descriptorType,
    uint32_t                                    descriptorCount,
    VkShaderStageFlags                          stageFlags,
    const std::vector<VkSampler> &              vecImmutableSamplers)
   {
      std::shared_ptr<VkDescriptorSetLayoutBindingRAII> raii_obj(new VkDescriptorSetLayoutBindingRAII);
      raii_obj->nonRaiiObj.binding = binding;
      raii_obj->nonRaiiObj.descriptorType = descriptorType;
      raii_obj->nonRaiiObj.descriptorCount = descriptorCount;
      raii_obj->nonRaiiObj.stageFlags = stageFlags;
      raii_obj->vecImmutableSamplers = vecImmutableSamplers;
      if ( raii_obj->vecImmutableSamplers.size() > 0)
      {
          raii_obj->nonRaiiObj.pImmutableSamplers = &raii_obj->vecImmutableSamplers[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImmutableSamplers = nullptr;
      }
      return raii_obj;
   }

struct VkDescriptorSetLayoutCreateInfoRAII {
   VkDescriptorSetLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayoutBinding>   vecBindings;
};

std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> DescriptorSetLayoutCreateInfo(
    VkDescriptorSetLayoutCreateFlags            flags,
    const std::vector<VkDescriptorSetLayoutBinding> &vecBindings)
   {
      std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> raii_obj(new VkDescriptorSetLayoutCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.bindingCount = static_cast<uint32_t>(vecBindings.size());
      raii_obj->vecBindings = vecBindings;
      if ( raii_obj->vecBindings.size() > 0)
      {
          raii_obj->nonRaiiObj.pBindings = &raii_obj->vecBindings[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBindings = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkDescriptorSetLayout_T> createDescriptorSetLayout(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo)
   {
      VkDescriptorSetLayout hSetLayout; 
      V( vkCreateDescriptorSetLayout(
          device,
          &pCreateInfo,
          nullptr,
          &hSetLayout  ));
      return std::shared_ptr<VkDescriptorSetLayout_T>(hSetLayout, 
              [=](VkDescriptorSetLayout to_free) {vkDestroyDescriptorSetLayout(device, to_free, nullptr);});
   }

VkDescriptorPoolSize DescriptorPoolSize(
    VkDescriptorType                            type,
    uint32_t                                    descriptorCount)
   {
      VkDescriptorPoolSize obj;
      obj.type = type;
      obj.descriptorCount = descriptorCount;
      return obj;
   }

struct VkDescriptorPoolCreateInfoRAII {
   VkDescriptorPoolCreateInfo nonRaiiObj;
    std::vector<VkDescriptorPoolSize>           vecPoolSizes;
};

std::shared_ptr<VkDescriptorPoolCreateInfoRAII> DescriptorPoolCreateInfo(
    VkDescriptorPoolCreateFlags                 flags,
    uint32_t                                    maxSets,
    const std::vector<VkDescriptorPoolSize> &   vecPoolSizes)
   {
      std::shared_ptr<VkDescriptorPoolCreateInfoRAII> raii_obj(new VkDescriptorPoolCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.maxSets = maxSets;
      raii_obj->nonRaiiObj.poolSizeCount = static_cast<uint32_t>(vecPoolSizes.size());
      raii_obj->vecPoolSizes = vecPoolSizes;
      if ( raii_obj->vecPoolSizes.size() > 0)
      {
          raii_obj->nonRaiiObj.pPoolSizes = &raii_obj->vecPoolSizes[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPoolSizes = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkDescriptorPool_T> createDescriptorPool(
        VkDevice device,
        const VkDescriptorPoolCreateInfo & pCreateInfo)
   {
      VkDescriptorPool hDescriptorPool; 
      V( vkCreateDescriptorPool(
          device,
          &pCreateInfo,
          nullptr,
          &hDescriptorPool  ));
      return std::shared_ptr<VkDescriptorPool_T>(hDescriptorPool, 
              [=](VkDescriptorPool to_free) {vkDestroyDescriptorPool(device, to_free, nullptr);});
   }

void  resetDescriptorPool(
        VkDevice device,
        VkDescriptorPool descriptorPool,
        VkDescriptorPoolResetFlags flags)
   {
      V( vkResetDescriptorPool(
          device,
          descriptorPool,
          flags  ));
   }

struct VkDescriptorSetAllocateInfoRAII {
   VkDescriptorSetAllocateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
};

std::shared_ptr<VkDescriptorSetAllocateInfoRAII> DescriptorSetAllocateInfo(
    VkDescriptorPool                            descriptorPool,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts)
   {
      std::shared_ptr<VkDescriptorSetAllocateInfoRAII> raii_obj(new VkDescriptorSetAllocateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.descriptorPool = descriptorPool;
      raii_obj->nonRaiiObj.descriptorSetCount = static_cast<uint32_t>(vecSetLayouts.size());
      raii_obj->vecSetLayouts = vecSetLayouts;
      if ( raii_obj->vecSetLayouts.size() > 0)
      {
          raii_obj->nonRaiiObj.pSetLayouts = &raii_obj->vecSetLayouts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSetLayouts = nullptr;
      }
      return raii_obj;
   }

VkDescriptorImageInfo DescriptorImageInfo(
    VkSampler                                   sampler,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout)
   {
      VkDescriptorImageInfo obj;
      obj.sampler = sampler;
      obj.imageView = imageView;
      obj.imageLayout = imageLayout;
      return obj;
   }

VkDescriptorBufferInfo DescriptorBufferInfo(
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                range)
   {
      VkDescriptorBufferInfo obj;
      obj.buffer = buffer;
      obj.offset = offset;
      obj.range = range;
      return obj;
   }

struct VkWriteDescriptorSetRAII {
   VkWriteDescriptorSet nonRaiiObj;
    std::vector<VkDescriptorImageInfo>          vecImageInfo;
    std::vector<VkDescriptorBufferInfo>         vecBufferInfo;
    std::vector<VkBufferView>                   vecTexelBufferView;
};

std::shared_ptr<VkWriteDescriptorSetRAII> WriteDescriptorSet(
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    const std::vector<VkDescriptorImageInfo> &  vecImageInfo,
    const std::vector<VkDescriptorBufferInfo> & vecBufferInfo,
    const std::vector<VkBufferView> &           vecTexelBufferView)
   {
      std::shared_ptr<VkWriteDescriptorSetRAII> raii_obj(new VkWriteDescriptorSetRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.dstSet = dstSet;
      raii_obj->nonRaiiObj.dstBinding = dstBinding;
      raii_obj->nonRaiiObj.dstArrayElement = dstArrayElement;
      raii_obj->nonRaiiObj.descriptorCount = descriptorCount;
      raii_obj->nonRaiiObj.descriptorType = descriptorType;
      raii_obj->vecImageInfo = vecImageInfo;
      if ( raii_obj->vecImageInfo.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageInfo = &raii_obj->vecImageInfo[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageInfo = nullptr;
      }
      raii_obj->vecBufferInfo = vecBufferInfo;
      if ( raii_obj->vecBufferInfo.size() > 0)
      {
          raii_obj->nonRaiiObj.pBufferInfo = &raii_obj->vecBufferInfo[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBufferInfo = nullptr;
      }
      raii_obj->vecTexelBufferView = vecTexelBufferView;
      if ( raii_obj->vecTexelBufferView.size() > 0)
      {
          raii_obj->nonRaiiObj.pTexelBufferView = &raii_obj->vecTexelBufferView[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pTexelBufferView = nullptr;
      }
      return raii_obj;
   }

VkCopyDescriptorSet CopyDescriptorSet(
    VkDescriptorSet                             srcSet,
    uint32_t                                    srcBinding,
    uint32_t                                    srcArrayElement,
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount)
   {
      VkCopyDescriptorSet obj;
      obj.sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
      obj.pNext = nullptr;
      obj.srcSet = srcSet;
      obj.srcBinding = srcBinding;
      obj.srcArrayElement = srcArrayElement;
      obj.dstSet = dstSet;
      obj.dstBinding = dstBinding;
      obj.dstArrayElement = dstArrayElement;
      obj.descriptorCount = descriptorCount;
      return obj;
   }

void  updateDescriptorSets(
        VkDevice device,
        const std::vector<VkWriteDescriptorSet> & pDescriptorWrites,
        const std::vector<VkCopyDescriptorSet> & pDescriptorCopies)
   {
      vkUpdateDescriptorSets(
          device,
          static_cast<uint32_t>(pDescriptorWrites.size()),
          &pDescriptorWrites[0],
          static_cast<uint32_t>(pDescriptorCopies.size()),
          &pDescriptorCopies[0]  );
   }

struct VkFramebufferCreateInfoRAII {
   VkFramebufferCreateInfo nonRaiiObj;
    std::vector<VkImageView>                    vecAttachments;
};

std::shared_ptr<VkFramebufferCreateInfoRAII> FramebufferCreateInfo(
    VkFramebufferCreateFlags                    flags,
    VkRenderPass                                renderPass,
    const std::vector<VkImageView> &            vecAttachments,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    layers)
   {
      std::shared_ptr<VkFramebufferCreateInfoRAII> raii_obj(new VkFramebufferCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.width = width;
      raii_obj->nonRaiiObj.height = height;
      raii_obj->nonRaiiObj.layers = layers;
      return raii_obj;
   }

std::shared_ptr<VkFramebuffer_T> createFramebuffer(
        VkDevice device,
        const VkFramebufferCreateInfo & pCreateInfo)
   {
      VkFramebuffer hFramebuffer; 
      V( vkCreateFramebuffer(
          device,
          &pCreateInfo,
          nullptr,
          &hFramebuffer  ));
      return std::shared_ptr<VkFramebuffer_T>(hFramebuffer, 
              [=](VkFramebuffer to_free) {vkDestroyFramebuffer(device, to_free, nullptr);});
   }

VkAttachmentDescription AttachmentDescription(
    VkAttachmentDescriptionFlags                flags,
    VkFormat                                    format,
    VkSampleCountFlagBits                       samples,
    VkAttachmentLoadOp                          loadOp,
    VkAttachmentStoreOp                         storeOp,
    VkAttachmentLoadOp                          stencilLoadOp,
    VkAttachmentStoreOp                         stencilStoreOp,
    VkImageLayout                               initialLayout,
    VkImageLayout                               finalLayout)
   {
      VkAttachmentDescription obj;
      obj.flags = flags;
      obj.format = format;
      obj.samples = samples;
      obj.loadOp = loadOp;
      obj.storeOp = storeOp;
      obj.stencilLoadOp = stencilLoadOp;
      obj.stencilStoreOp = stencilStoreOp;
      obj.initialLayout = initialLayout;
      obj.finalLayout = finalLayout;
      return obj;
   }

VkAttachmentReference AttachmentReference(
    uint32_t                                    attachment,
    VkImageLayout                               layout)
   {
      VkAttachmentReference obj;
      obj.attachment = attachment;
      obj.layout = layout;
      return obj;
   }

struct VkSubpassDescriptionRAII {
   VkSubpassDescription nonRaiiObj;
    std::vector<VkAttachmentReference>          vecInputAttachments;
    std::vector<VkAttachmentReference>          vecColorAttachments;
    std::vector<VkAttachmentReference>          vecResolveAttachments;
    std::shared_ptr<VkAttachmentReference>      pDepthStencilAttachment;
    std::vector<uint32_t>                       vecPreserveAttachments;
};

std::shared_ptr<VkSubpassDescriptionRAII> SubpassDescription(
    VkSubpassDescriptionFlags                   flags,
    VkPipelineBindPoint                         pipelineBindPoint,
    const std::vector<VkAttachmentReference> &  vecInputAttachments,
    const std::vector<VkAttachmentReference> &  vecColorAttachments,
    const std::vector<VkAttachmentReference> &  vecResolveAttachments,
    const VkAttachmentReference *               pDepthStencilAttachment,
    unsigned int* pPreserveAttachments_in_array1, int pPreserveAttachments_dim1)
   {
      std::shared_ptr<VkSubpassDescriptionRAII> raii_obj(new VkSubpassDescriptionRAII);
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.pipelineBindPoint = pipelineBindPoint;
      raii_obj->nonRaiiObj.inputAttachmentCount = static_cast<uint32_t>(vecInputAttachments.size());
      raii_obj->vecInputAttachments = vecInputAttachments;
      if ( raii_obj->vecInputAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pInputAttachments = &raii_obj->vecInputAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pInputAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.colorAttachmentCount = static_cast<uint32_t>(vecColorAttachments.size());
      raii_obj->vecColorAttachments = vecColorAttachments;
      if ( raii_obj->vecColorAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pColorAttachments = &raii_obj->vecColorAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pColorAttachments = nullptr;
      }
      raii_obj->vecResolveAttachments = vecResolveAttachments;
      if ( raii_obj->vecResolveAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pResolveAttachments = &raii_obj->vecResolveAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pResolveAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.pDepthStencilAttachment = nullptr;
      if ( pDepthStencilAttachment ) 
      { 
          raii_obj->pDepthStencilAttachment.reset( new VkAttachmentReference );
          *raii_obj->pDepthStencilAttachment = *pDepthStencilAttachment;
          raii_obj->nonRaiiObj.pDepthStencilAttachment = raii_obj->pDepthStencilAttachment.get();
      } 
      raii_obj->nonRaiiObj.preserveAttachmentCount = static_cast<uint32_t>(pPreserveAttachments_dim1);
      raii_obj->vecPreserveAttachments.assign(pPreserveAttachments_in_array1, pPreserveAttachments_in_array1 + pPreserveAttachments_dim1);
      if ( raii_obj->vecPreserveAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pPreserveAttachments = &raii_obj->vecPreserveAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPreserveAttachments = nullptr;
      }
      return raii_obj;
   }

VkSubpassDependency SubpassDependency(
    uint32_t                                    srcSubpass,
    uint32_t                                    dstSubpass,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkDependencyFlags                           dependencyFlags)
   {
      VkSubpassDependency obj;
      obj.srcSubpass = srcSubpass;
      obj.dstSubpass = dstSubpass;
      obj.srcStageMask = srcStageMask;
      obj.dstStageMask = dstStageMask;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.dependencyFlags = dependencyFlags;
      return obj;
   }

struct VkRenderPassCreateInfoRAII {
   VkRenderPassCreateInfo nonRaiiObj;
    std::vector<VkAttachmentDescription>        vecAttachments;
    std::vector<VkSubpassDescription>           vecSubpasses;
    std::vector<VkSubpassDependency>            vecDependencies;
};

std::shared_ptr<VkRenderPassCreateInfoRAII> RenderPassCreateInfo(
    VkRenderPassCreateFlags                     flags,
    const std::vector<VkAttachmentDescription> &vecAttachments,
    const std::vector<VkSubpassDescription> &   vecSubpasses,
    const std::vector<VkSubpassDependency> &    vecDependencies)
   {
      std::shared_ptr<VkRenderPassCreateInfoRAII> raii_obj(new VkRenderPassCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.subpassCount = static_cast<uint32_t>(vecSubpasses.size());
      raii_obj->vecSubpasses = vecSubpasses;
      if ( raii_obj->vecSubpasses.size() > 0)
      {
          raii_obj->nonRaiiObj.pSubpasses = &raii_obj->vecSubpasses[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSubpasses = nullptr;
      }
      raii_obj->nonRaiiObj.dependencyCount = static_cast<uint32_t>(vecDependencies.size());
      raii_obj->vecDependencies = vecDependencies;
      if ( raii_obj->vecDependencies.size() > 0)
      {
          raii_obj->nonRaiiObj.pDependencies = &raii_obj->vecDependencies[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDependencies = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkRenderPass_T> createRenderPass(
        VkDevice device,
        const VkRenderPassCreateInfo & pCreateInfo)
   {
      VkRenderPass hRenderPass; 
      V( vkCreateRenderPass(
          device,
          &pCreateInfo,
          nullptr,
          &hRenderPass  ));
      return std::shared_ptr<VkRenderPass_T>(hRenderPass, 
              [=](VkRenderPass to_free) {vkDestroyRenderPass(device, to_free, nullptr);});
   }

VkExtent2D getRenderAreaGranularity(
        VkDevice device,
        VkRenderPass renderPass)
   {
      VkExtent2D pGranularity; 
      vkGetRenderAreaGranularity(
          device,
          renderPass,
          &pGranularity  );
      return pGranularity; 
   }

VkCommandPoolCreateInfo CommandPoolCreateInfo(
    VkCommandPoolCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex)
   {
      VkCommandPoolCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.queueFamilyIndex = queueFamilyIndex;
      return obj;
   }

std::shared_ptr<VkCommandPool_T> createCommandPool(
        VkDevice device,
        const VkCommandPoolCreateInfo & pCreateInfo)
   {
      VkCommandPool hCommandPool; 
      V( vkCreateCommandPool(
          device,
          &pCreateInfo,
          nullptr,
          &hCommandPool  ));
      return std::shared_ptr<VkCommandPool_T>(hCommandPool, 
              [=](VkCommandPool to_free) {vkDestroyCommandPool(device, to_free, nullptr);});
   }

void  resetCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolResetFlags flags)
   {
      V( vkResetCommandPool(
          device,
          commandPool,
          flags  ));
   }

VkCommandBufferAllocateInfo CommandBufferAllocateInfo(
    VkCommandPool                               commandPool,
    VkCommandBufferLevel                        level,
    uint32_t                                    commandBufferCount)
   {
      VkCommandBufferAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.commandPool = commandPool;
      obj.level = level;
      obj.commandBufferCount = commandBufferCount;
      return obj;
   }

VkCommandBufferInheritanceInfo CommandBufferInheritanceInfo(
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkFramebuffer                               framebuffer,
    VkBool32                                    occlusionQueryEnable,
    VkQueryControlFlags                         queryFlags,
    VkQueryPipelineStatisticFlags               pipelineStatistics)
   {
      VkCommandBufferInheritanceInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
      obj.pNext = nullptr;
      obj.renderPass = renderPass;
      obj.subpass = subpass;
      obj.framebuffer = framebuffer;
      obj.occlusionQueryEnable = occlusionQueryEnable;
      obj.queryFlags = queryFlags;
      obj.pipelineStatistics = pipelineStatistics;
      return obj;
   }

struct VkCommandBufferBeginInfoRAII {
   VkCommandBufferBeginInfo nonRaiiObj;
    std::shared_ptr<VkCommandBufferInheritanceInfo>pInheritanceInfo;
};

std::shared_ptr<VkCommandBufferBeginInfoRAII> CommandBufferBeginInfo(
    VkCommandBufferUsageFlags                   flags,
    const VkCommandBufferInheritanceInfo *      pInheritanceInfo)
   {
      std::shared_ptr<VkCommandBufferBeginInfoRAII> raii_obj(new VkCommandBufferBeginInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.pInheritanceInfo = nullptr;
      if ( pInheritanceInfo ) 
      { 
          raii_obj->pInheritanceInfo.reset( new VkCommandBufferInheritanceInfo );
          *raii_obj->pInheritanceInfo = *pInheritanceInfo;
          raii_obj->nonRaiiObj.pInheritanceInfo = raii_obj->pInheritanceInfo.get();
      } 
      return raii_obj;
   }

void  beginCommandBuffer(
        VkCommandBuffer commandBuffer,
        const VkCommandBufferBeginInfo & pBeginInfo)
   {
      V( vkBeginCommandBuffer(
          commandBuffer,
          &pBeginInfo  ));
   }

void  endCommandBuffer(
        VkCommandBuffer commandBuffer)
   {
      V( vkEndCommandBuffer(
          commandBuffer  ));
   }

void  resetCommandBuffer(
        VkCommandBuffer commandBuffer,
        VkCommandBufferResetFlags flags)
   {
      V( vkResetCommandBuffer(
          commandBuffer,
          flags  ));
   }

void  cmdBindPipeline(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipeline pipeline)
   {
      vkCmdBindPipeline(
          commandBuffer,
          pipelineBindPoint,
          pipeline  );
   }

void  cmdSetViewport(
        VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        const std::vector<VkViewport> & pViewports)
   {
      vkCmdSetViewport(
          commandBuffer,
          firstViewport,
          static_cast<uint32_t>(pViewports.size()),
          &pViewports[0]  );
   }

void  cmdSetScissor(
        VkCommandBuffer commandBuffer,
        uint32_t firstScissor,
        const std::vector<VkRect2D> & pScissors)
   {
      vkCmdSetScissor(
          commandBuffer,
          firstScissor,
          static_cast<uint32_t>(pScissors.size()),
          &pScissors[0]  );
   }

void  cmdSetLineWidth(
        VkCommandBuffer commandBuffer,
        float lineWidth)
   {
      vkCmdSetLineWidth(
          commandBuffer,
          lineWidth  );
   }

void  cmdSetDepthBias(
        VkCommandBuffer commandBuffer,
        float depthBiasConstantFactor,
        float depthBiasClamp,
        float depthBiasSlopeFactor)
   {
      vkCmdSetDepthBias(
          commandBuffer,
          depthBiasConstantFactor,
          depthBiasClamp,
          depthBiasSlopeFactor  );
   }

void  cmdSetBlendConstants(
        VkCommandBuffer commandBuffer,
        const float blendConstants[4])
   {
      vkCmdSetBlendConstants(
          commandBuffer,
          blendConstants  );
   }

void  cmdSetDepthBounds(
        VkCommandBuffer commandBuffer,
        float minDepthBounds,
        float maxDepthBounds)
   {
      vkCmdSetDepthBounds(
          commandBuffer,
          minDepthBounds,
          maxDepthBounds  );
   }

void  cmdSetStencilCompareMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t compareMask)
   {
      vkCmdSetStencilCompareMask(
          commandBuffer,
          faceMask,
          compareMask  );
   }

void  cmdSetStencilWriteMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t writeMask)
   {
      vkCmdSetStencilWriteMask(
          commandBuffer,
          faceMask,
          writeMask  );
   }

void  cmdSetStencilReference(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t reference)
   {
      vkCmdSetStencilReference(
          commandBuffer,
          faceMask,
          reference  );
   }

void  cmdBindDescriptorSets(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t firstSet,
        const std::vector<VkDescriptorSet> & pDescriptorSets,
        unsigned int* pDynamicOffsets_in_array1, int pDynamicOffsets_dim1)
   {
      vkCmdBindDescriptorSets(
          commandBuffer,
          pipelineBindPoint,
          layout,
          firstSet,
          static_cast<uint32_t>(pDescriptorSets.size()),
          &pDescriptorSets[0],
          static_cast<uint32_t>(pDynamicOffsets_dim1),
          pDynamicOffsets_in_array1  );
   }

void  cmdBindIndexBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkIndexType indexType)
   {
      vkCmdBindIndexBuffer(
          commandBuffer,
          buffer,
          offset,
          indexType  );
   }

void  cmdBindVertexBuffers(
        VkCommandBuffer commandBuffer,
        uint32_t firstBinding,
        const std::vector<VkBuffer> & pBuffers,
        const std::vector<VkDeviceSize> & pOffsets)
   {
      vkCmdBindVertexBuffers(
          commandBuffer,
          firstBinding,
          static_cast<uint32_t>(pOffsets.size()),
          &pBuffers[0],
          &pOffsets[0]  );
   }

void  cmdDraw(
        VkCommandBuffer commandBuffer,
        uint32_t vertexCount,
        uint32_t instanceCount,
        uint32_t firstVertex,
        uint32_t firstInstance)
   {
      vkCmdDraw(
          commandBuffer,
          vertexCount,
          instanceCount,
          firstVertex,
          firstInstance  );
   }

void  cmdDrawIndexed(
        VkCommandBuffer commandBuffer,
        uint32_t indexCount,
        uint32_t instanceCount,
        uint32_t firstIndex,
        int32_t vertexOffset,
        uint32_t firstInstance)
   {
      vkCmdDrawIndexed(
          commandBuffer,
          indexCount,
          instanceCount,
          firstIndex,
          vertexOffset,
          firstInstance  );
   }

void  cmdDrawIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride)
   {
      vkCmdDrawIndirect(
          commandBuffer,
          buffer,
          offset,
          drawCount,
          stride  );
   }

void  cmdDrawIndexedIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride)
   {
      vkCmdDrawIndexedIndirect(
          commandBuffer,
          buffer,
          offset,
          drawCount,
          stride  );
   }

void  cmdDispatch(
        VkCommandBuffer commandBuffer,
        uint32_t x,
        uint32_t y,
        uint32_t z)
   {
      vkCmdDispatch(
          commandBuffer,
          x,
          y,
          z  );
   }

void  cmdDispatchIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset)
   {
      vkCmdDispatchIndirect(
          commandBuffer,
          buffer,
          offset  );
   }

VkBufferCopy BufferCopy(
    VkDeviceSize                                srcOffset,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size)
   {
      VkBufferCopy obj;
      obj.srcOffset = srcOffset;
      obj.dstOffset = dstOffset;
      obj.size = size;
      return obj;
   }

void  cmdCopyBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkBuffer dstBuffer,
        const std::vector<VkBufferCopy> & pRegions)
   {
      vkCmdCopyBuffer(
          commandBuffer,
          srcBuffer,
          dstBuffer,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

VkImageSubresourceLayers ImageSubresourceLayers(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkImageSubresourceLayers obj;
      obj.aspectMask = aspectMask;
      obj.mipLevel = mipLevel;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

VkImageCopy ImageCopy(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent)
   {
      VkImageCopy obj;
      obj.srcSubresource = srcSubresource;
      obj.srcOffset = srcOffset;
      obj.dstSubresource = dstSubresource;
      obj.dstOffset = dstOffset;
      obj.extent = extent;
      return obj;
   }

void  cmdCopyImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageCopy> & pRegions)
   {
      vkCmdCopyImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

VkImageBlit ImageBlit(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffsets[2],
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffsets[2])
   {
      VkImageBlit obj;
      obj.srcSubresource = srcSubresource;
      std::copy(srcOffsets, srcOffsets + 2, obj.srcOffsets);
      obj.dstSubresource = dstSubresource;
      std::copy(dstOffsets, dstOffsets + 2, obj.dstOffsets);
      return obj;
   }

void  cmdBlitImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageBlit> & pRegions,
        VkFilter filter)
   {
      vkCmdBlitImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0],
          filter  );
   }

VkBufferImageCopy BufferImageCopy(
    VkDeviceSize                                bufferOffset,
    uint32_t                                    bufferRowLength,
    uint32_t                                    bufferImageHeight,
    VkImageSubresourceLayers                    imageSubresource,
    VkOffset3D                                  imageOffset,
    VkExtent3D                                  imageExtent)
   {
      VkBufferImageCopy obj;
      obj.bufferOffset = bufferOffset;
      obj.bufferRowLength = bufferRowLength;
      obj.bufferImageHeight = bufferImageHeight;
      obj.imageSubresource = imageSubresource;
      obj.imageOffset = imageOffset;
      obj.imageExtent = imageExtent;
      return obj;
   }

void  cmdCopyBufferToImage(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkBufferImageCopy> & pRegions)
   {
      vkCmdCopyBufferToImage(
          commandBuffer,
          srcBuffer,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdCopyImageToBuffer(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkBuffer dstBuffer,
        const std::vector<VkBufferImageCopy> & pRegions)
   {
      vkCmdCopyImageToBuffer(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstBuffer,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdUpdateBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        const std::vector<unsigned char> & pData)
   {
      vkCmdUpdateBuffer(
          commandBuffer,
          dstBuffer,
          dstOffset,
          static_cast<uint32_t>(pData.size()),
          reinterpret_cast<const void*>(&pData[0])  );
   }

void  cmdFillBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize size,
        uint32_t data)
   {
      vkCmdFillBuffer(
          commandBuffer,
          dstBuffer,
          dstOffset,
          size,
          data  );
   }

void  cmdClearColorImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearColorValue & pColor,
        const std::vector<VkImageSubresourceRange> & pRanges)
   {
      vkCmdClearColorImage(
          commandBuffer,
          image,
          imageLayout,
          &pColor,
          static_cast<uint32_t>(pRanges.size()),
          &pRanges[0]  );
   }

VkClearDepthStencilValue ClearDepthStencilValue(
    float                                       depth,
    uint32_t                                    stencil)
   {
      VkClearDepthStencilValue obj;
      obj.depth = depth;
      obj.stencil = stencil;
      return obj;
   }

void  cmdClearDepthStencilImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearDepthStencilValue & pDepthStencil,
        const std::vector<VkImageSubresourceRange> & pRanges)
   {
      vkCmdClearDepthStencilImage(
          commandBuffer,
          image,
          imageLayout,
          &pDepthStencil,
          static_cast<uint32_t>(pRanges.size()),
          &pRanges[0]  );
   }

VkClearAttachment ClearAttachment(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    colorAttachment,
    VkClearValue                                clearValue)
   {
      VkClearAttachment obj;
      obj.aspectMask = aspectMask;
      obj.colorAttachment = colorAttachment;
      obj.clearValue = clearValue;
      return obj;
   }

VkClearRect ClearRect(
    VkRect2D                                    rect,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkClearRect obj;
      obj.rect = rect;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

void  cmdClearAttachments(
        VkCommandBuffer commandBuffer,
        const std::vector<VkClearAttachment> & pAttachments,
        const std::vector<VkClearRect> & pRects)
   {
      vkCmdClearAttachments(
          commandBuffer,
          static_cast<uint32_t>(pAttachments.size()),
          &pAttachments[0],
          static_cast<uint32_t>(pRects.size()),
          &pRects[0]  );
   }

VkImageResolve ImageResolve(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent)
   {
      VkImageResolve obj;
      obj.srcSubresource = srcSubresource;
      obj.srcOffset = srcOffset;
      obj.dstSubresource = dstSubresource;
      obj.dstOffset = dstOffset;
      obj.extent = extent;
      return obj;
   }

void  cmdResolveImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageResolve> & pRegions)
   {
      vkCmdResolveImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdSetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask)
   {
      vkCmdSetEvent(
          commandBuffer,
          event,
          stageMask  );
   }

void  cmdResetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask)
   {
      vkCmdResetEvent(
          commandBuffer,
          event,
          stageMask  );
   }

VkMemoryBarrier MemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask)
   {
      VkMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      return obj;
   }

VkBufferMemoryBarrier BufferMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                size)
   {
      VkBufferMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.srcQueueFamilyIndex = srcQueueFamilyIndex;
      obj.dstQueueFamilyIndex = dstQueueFamilyIndex;
      obj.buffer = buffer;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

VkImageMemoryBarrier ImageMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkImageLayout                               oldLayout,
    VkImageLayout                               newLayout,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkImage                                     image,
    VkImageSubresourceRange                     subresourceRange)
   {
      VkImageMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.oldLayout = oldLayout;
      obj.newLayout = newLayout;
      obj.srcQueueFamilyIndex = srcQueueFamilyIndex;
      obj.dstQueueFamilyIndex = dstQueueFamilyIndex;
      obj.image = image;
      obj.subresourceRange = subresourceRange;
      return obj;
   }

void  cmdWaitEvents(
        VkCommandBuffer commandBuffer,
        const std::vector<VkEvent> & pEvents,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers)
   {
      vkCmdWaitEvents(
          commandBuffer,
          static_cast<uint32_t>(pEvents.size()),
          &pEvents[0],
          srcStageMask,
          dstStageMask,
          static_cast<uint32_t>(pMemoryBarriers.size()),
          &pMemoryBarriers[0],
          static_cast<uint32_t>(pBufferMemoryBarriers.size()),
          &pBufferMemoryBarriers[0],
          static_cast<uint32_t>(pImageMemoryBarriers.size()),
          &pImageMemoryBarriers[0]  );
   }

void  cmdPipelineBarrier(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        VkDependencyFlags dependencyFlags,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers)
   {
      vkCmdPipelineBarrier(
          commandBuffer,
          srcStageMask,
          dstStageMask,
          dependencyFlags,
          static_cast<uint32_t>(pMemoryBarriers.size()),
          &pMemoryBarriers[0],
          static_cast<uint32_t>(pBufferMemoryBarriers.size()),
          &pBufferMemoryBarriers[0],
          static_cast<uint32_t>(pImageMemoryBarriers.size()),
          &pImageMemoryBarriers[0]  );
   }

void  cmdBeginQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query,
        VkQueryControlFlags flags)
   {
      vkCmdBeginQuery(
          commandBuffer,
          queryPool,
          query,
          flags  );
   }

void  cmdEndQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query)
   {
      vkCmdEndQuery(
          commandBuffer,
          queryPool,
          query  );
   }

void  cmdResetQueryPool(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount)
   {
      vkCmdResetQueryPool(
          commandBuffer,
          queryPool,
          firstQuery,
          queryCount  );
   }

void  cmdWriteTimestamp(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlagBits pipelineStage,
        VkQueryPool queryPool,
        uint32_t query)
   {
      vkCmdWriteTimestamp(
          commandBuffer,
          pipelineStage,
          queryPool,
          query  );
   }

void  cmdCopyQueryPoolResults(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize stride,
        VkQueryResultFlags flags)
   {
      vkCmdCopyQueryPoolResults(
          commandBuffer,
          queryPool,
          firstQuery,
          queryCount,
          dstBuffer,
          dstOffset,
          stride,
          flags  );
   }

void  cmdPushConstants(
        VkCommandBuffer commandBuffer,
        VkPipelineLayout layout,
        VkShaderStageFlags stageFlags,
        uint32_t offset,
        const std::vector<unsigned char> & pValues)
   {
      vkCmdPushConstants(
          commandBuffer,
          layout,
          stageFlags,
          offset,
          static_cast<uint32_t>(pValues.size()),
          reinterpret_cast<const void*>(&pValues[0])  );
   }

struct VkRenderPassBeginInfoRAII {
   VkRenderPassBeginInfo nonRaiiObj;
    std::vector<VkClearValue>                   vecClearValues;
};

std::shared_ptr<VkRenderPassBeginInfoRAII> RenderPassBeginInfo(
    VkRenderPass                                renderPass,
    VkFramebuffer                               framebuffer,
    VkRect2D                                    renderArea,
    const std::vector<VkClearValue> &           vecClearValues)
   {
      std::shared_ptr<VkRenderPassBeginInfoRAII> raii_obj(new VkRenderPassBeginInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.framebuffer = framebuffer;
      raii_obj->nonRaiiObj.renderArea = renderArea;
      raii_obj->nonRaiiObj.clearValueCount = static_cast<uint32_t>(vecClearValues.size());
      raii_obj->vecClearValues = vecClearValues;
      if ( raii_obj->vecClearValues.size() > 0)
      {
          raii_obj->nonRaiiObj.pClearValues = &raii_obj->vecClearValues[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pClearValues = nullptr;
      }
      return raii_obj;
   }

void  cmdBeginRenderPass(
        VkCommandBuffer commandBuffer,
        const VkRenderPassBeginInfo & pRenderPassBegin,
        VkSubpassContents contents)
   {
      vkCmdBeginRenderPass(
          commandBuffer,
          &pRenderPassBegin,
          contents  );
   }

void  cmdNextSubpass(
        VkCommandBuffer commandBuffer,
        VkSubpassContents contents)
   {
      vkCmdNextSubpass(
          commandBuffer,
          contents  );
   }

void  cmdEndRenderPass(
        VkCommandBuffer commandBuffer)
   {
      vkCmdEndRenderPass(
          commandBuffer  );
   }

void  cmdExecuteCommands(
        VkCommandBuffer commandBuffer,
        const std::vector<VkCommandBuffer> & pCommandBuffers)
   {
      vkCmdExecuteCommands(
          commandBuffer,
          static_cast<uint32_t>(pCommandBuffers.size()),
          &pCommandBuffers[0]  );
   }

VkDispatchIndirectCommand DispatchIndirectCommand(
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z)
   {
      VkDispatchIndirectCommand obj;
      obj.x = x;
      obj.y = y;
      obj.z = z;
      return obj;
   }

VkDrawIndexedIndirectCommand DrawIndexedIndirectCommand(
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance)
   {
      VkDrawIndexedIndirectCommand obj;
      obj.indexCount = indexCount;
      obj.instanceCount = instanceCount;
      obj.firstIndex = firstIndex;
      obj.vertexOffset = vertexOffset;
      obj.firstInstance = firstInstance;
      return obj;
   }

VkDrawIndirectCommand DrawIndirectCommand(
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance)
   {
      VkDrawIndirectCommand obj;
      obj.vertexCount = vertexCount;
      obj.instanceCount = instanceCount;
      obj.firstVertex = firstVertex;
      obj.firstInstance = firstInstance;
      return obj;
   }

VkBool32 getPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VkSurfaceKHR surface)
   {
      VkBool32 pSupported; 
      V( vkGetPhysicalDeviceSurfaceSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          surface,
          &pSupported  ));
      return pSupported; 
   }

VkSurfaceCapabilitiesKHR SurfaceCapabilitiesKHR(
    uint32_t                                    minImageCount,
    uint32_t                                    maxImageCount,
    VkExtent2D                                  currentExtent,
    VkExtent2D                                  minImageExtent,
    VkExtent2D                                  maxImageExtent,
    uint32_t                                    maxImageArrayLayers,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkSurfaceTransformFlagBitsKHR               currentTransform,
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha,
    VkImageUsageFlags                           supportedUsageFlags)
   {
      VkSurfaceCapabilitiesKHR obj;
      obj.minImageCount = minImageCount;
      obj.maxImageCount = maxImageCount;
      obj.currentExtent = currentExtent;
      obj.minImageExtent = minImageExtent;
      obj.maxImageExtent = maxImageExtent;
      obj.maxImageArrayLayers = maxImageArrayLayers;
      obj.supportedTransforms = supportedTransforms;
      obj.currentTransform = currentTransform;
      obj.supportedCompositeAlpha = supportedCompositeAlpha;
      obj.supportedUsageFlags = supportedUsageFlags;
      return obj;
   }

VkSurfaceCapabilitiesKHR getPhysicalDeviceSurfaceCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      VkSurfaceCapabilitiesKHR pSurfaceCapabilities; 
      V( vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
          physicalDevice,
          surface,
          &pSurfaceCapabilities  ));
      return pSurfaceCapabilities; 
   }

VkSurfaceFormatKHR SurfaceFormatKHR(
    VkFormat                                    format,
    VkColorSpaceKHR                             colorSpace)
   {
      VkSurfaceFormatKHR obj;
      obj.format = format;
      obj.colorSpace = colorSpace;
      return obj;
   }

std::vector< VkSurfaceFormatKHR > getPhysicalDeviceSurfaceFormatsKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      std::vector<VkSurfaceFormatKHR> vecpSurfaceFormats; 
      uint32_t pSurfaceFormatsCount; 
      V( vkGetPhysicalDeviceSurfaceFormatsKHR(
          physicalDevice,
          surface,
          &pSurfaceFormatsCount,
          nullptr  ));

      vecpSurfaceFormats.resize(pSurfaceFormatsCount); 

      V( vkGetPhysicalDeviceSurfaceFormatsKHR(
          physicalDevice,
          surface,
          &pSurfaceFormatsCount,
          &vecpSurfaceFormats[0]  ));
      return vecpSurfaceFormats; 
   }

std::vector< VkPresentModeKHR > getPhysicalDeviceSurfacePresentModesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      std::vector<VkPresentModeKHR> vecpPresentModes; 
      uint32_t pPresentModesCount; 
      V( vkGetPhysicalDeviceSurfacePresentModesKHR(
          physicalDevice,
          surface,
          &pPresentModesCount,
          nullptr  ));

      vecpPresentModes.resize(pPresentModesCount); 

      V( vkGetPhysicalDeviceSurfacePresentModesKHR(
          physicalDevice,
          surface,
          &pPresentModesCount,
          &vecpPresentModes[0]  ));
      return vecpPresentModes; 
   }

struct VkSwapchainCreateInfoKHRRAII {
   VkSwapchainCreateInfoKHR nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkSwapchainCreateInfoKHRRAII> SwapchainCreateInfoKHR(
    VkSwapchainCreateFlagsKHR                   flags,
    VkSurfaceKHR                                surface,
    uint32_t                                    minImageCount,
    VkFormat                                    imageFormat,
    VkColorSpaceKHR                             imageColorSpace,
    VkExtent2D                                  imageExtent,
    uint32_t                                    imageArrayLayers,
    VkImageUsageFlags                           imageUsage,
    VkSharingMode                               imageSharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkSurfaceTransformFlagBitsKHR               preTransform,
    VkCompositeAlphaFlagBitsKHR                 compositeAlpha,
    VkPresentModeKHR                            presentMode,
    VkBool32                                    clipped,
    VkSwapchainKHR                              oldSwapchain)
   {
      std::shared_ptr<VkSwapchainCreateInfoKHRRAII> raii_obj(new VkSwapchainCreateInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.surface = surface;
      raii_obj->nonRaiiObj.minImageCount = minImageCount;
      raii_obj->nonRaiiObj.imageFormat = imageFormat;
      raii_obj->nonRaiiObj.imageColorSpace = imageColorSpace;
      raii_obj->nonRaiiObj.imageExtent = imageExtent;
      raii_obj->nonRaiiObj.imageArrayLayers = imageArrayLayers;
      raii_obj->nonRaiiObj.imageUsage = imageUsage;
      raii_obj->nonRaiiObj.imageSharingMode = imageSharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      raii_obj->nonRaiiObj.preTransform = preTransform;
      raii_obj->nonRaiiObj.compositeAlpha = compositeAlpha;
      raii_obj->nonRaiiObj.presentMode = presentMode;
      raii_obj->nonRaiiObj.clipped = clipped;
      raii_obj->nonRaiiObj.oldSwapchain = oldSwapchain;
      return raii_obj;
   }

std::shared_ptr<VkSwapchainKHR_T> createSwapchainKHR(
        VkDevice device,
        const VkSwapchainCreateInfoKHR & pCreateInfo)
   {
      VkSwapchainKHR hSwapchain; 
      V( vkCreateSwapchainKHR(
          device,
          &pCreateInfo,
          nullptr,
          &hSwapchain  ));
      return std::shared_ptr<VkSwapchainKHR_T>(hSwapchain, 
              [=](VkSwapchainKHR to_free) {vkDestroySwapchainKHR(device, to_free, nullptr);});
   }

std::vector< VkImage > getSwapchainImagesKHR(
        VkDevice device,
        VkSwapchainKHR swapchain)
   {
      std::vector<VkImage> vecpSwapchainImages; 
      uint32_t pSwapchainImagesCount; 
      V( vkGetSwapchainImagesKHR(
          device,
          swapchain,
          &pSwapchainImagesCount,
          nullptr  ));

      vecpSwapchainImages.resize(pSwapchainImagesCount); 

      V( vkGetSwapchainImagesKHR(
          device,
          swapchain,
          &pSwapchainImagesCount,
          &vecpSwapchainImages[0]  ));
      return vecpSwapchainImages; 
   }

uint32_t acquireNextImageKHR(
        VkDevice device,
        VkSwapchainKHR swapchain,
        uint64_t timeout,
        VkSemaphore semaphore,
        VkFence fence)
   {
      uint32_t pImageIndex; 
      V( vkAcquireNextImageKHR(
          device,
          swapchain,
          timeout,
          semaphore,
          fence,
          &pImageIndex  ));
      return pImageIndex; 
   }

struct VkPresentInfoKHRRAII {
   VkPresentInfoKHR nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSwapchainKHR>                 vecSwapchains;
    std::vector<uint32_t>                       vecImageIndices;
    std::vector<VkResult>                       vecResults;
};

std::shared_ptr<VkPresentInfoKHRRAII> PresentInfoKHR(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSwapchainKHR> &         vecSwapchains,
    unsigned int* pImageIndices_in_array1, int pImageIndices_dim1,
    const std::vector<VkResult> &               vecResults)
   {
      std::shared_ptr<VkPresentInfoKHRRAII> raii_obj(new VkPresentInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->nonRaiiObj.swapchainCount = static_cast<uint32_t>(vecSwapchains.size());
      raii_obj->vecSwapchains = vecSwapchains;
      if ( raii_obj->vecSwapchains.size() > 0)
      {
          raii_obj->nonRaiiObj.pSwapchains = &raii_obj->vecSwapchains[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSwapchains = nullptr;
      }
      raii_obj->vecImageIndices.assign(pImageIndices_in_array1, pImageIndices_in_array1 + pImageIndices_dim1);
      if ( raii_obj->vecImageIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageIndices = &raii_obj->vecImageIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageIndices = nullptr;
      }
      raii_obj->vecResults = vecResults;
      if ( raii_obj->vecResults.size() > 0)
      {
          raii_obj->nonRaiiObj.pResults = &raii_obj->vecResults[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pResults = nullptr;
      }
      return raii_obj;
   }

void  queuePresentKHR(
        VkQueue queue,
        const VkPresentInfoKHR & pPresentInfo)
   {
      V( vkQueuePresentKHR(
          queue,
          &pPresentInfo  ));
   }

struct VkDisplayPropertiesKHRRAII {
   VkDisplayPropertiesKHR nonRaiiObj;
    std::string                                 strisplayName;
};

std::shared_ptr<VkDisplayPropertiesKHRRAII> DisplayPropertiesKHR(
    VkDisplayKHR                                display,
    const std::string &                         strisplayName,
    VkExtent2D                                  physicalDimensions,
    VkExtent2D                                  physicalResolution,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkBool32                                    planeReorderPossible,
    VkBool32                                    persistentContent)
   {
      std::shared_ptr<VkDisplayPropertiesKHRRAII> raii_obj(new VkDisplayPropertiesKHRRAII);
      raii_obj->nonRaiiObj.display = display;
      raii_obj->strisplayName = strisplayName;
      raii_obj->nonRaiiObj.displayName = &raii_obj->strisplayName[0];
      raii_obj->nonRaiiObj.physicalDimensions = physicalDimensions;
      raii_obj->nonRaiiObj.physicalResolution = physicalResolution;
      raii_obj->nonRaiiObj.supportedTransforms = supportedTransforms;
      raii_obj->nonRaiiObj.planeReorderPossible = planeReorderPossible;
      raii_obj->nonRaiiObj.persistentContent = persistentContent;
      return raii_obj;
   }

VkDisplayModeParametersKHR DisplayModeParametersKHR(
    VkExtent2D                                  visibleRegion,
    uint32_t                                    refreshRate)
   {
      VkDisplayModeParametersKHR obj;
      obj.visibleRegion = visibleRegion;
      obj.refreshRate = refreshRate;
      return obj;
   }

VkDisplayModePropertiesKHR DisplayModePropertiesKHR(
    VkDisplayModeKHR                            displayMode,
    VkDisplayModeParametersKHR                  parameters)
   {
      VkDisplayModePropertiesKHR obj;
      obj.displayMode = displayMode;
      obj.parameters = parameters;
      return obj;
   }

VkDisplayModeCreateInfoKHR DisplayModeCreateInfoKHR(
    VkDisplayModeCreateFlagsKHR                 flags,
    VkDisplayModeParametersKHR                  parameters)
   {
      VkDisplayModeCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.parameters = parameters;
      return obj;
   }

VkDisplayPlaneCapabilitiesKHR DisplayPlaneCapabilitiesKHR(
    VkDisplayPlaneAlphaFlagsKHR                 supportedAlpha,
    VkOffset2D                                  minSrcPosition,
    VkOffset2D                                  maxSrcPosition,
    VkExtent2D                                  minSrcExtent,
    VkExtent2D                                  maxSrcExtent,
    VkOffset2D                                  minDstPosition,
    VkOffset2D                                  maxDstPosition,
    VkExtent2D                                  minDstExtent,
    VkExtent2D                                  maxDstExtent)
   {
      VkDisplayPlaneCapabilitiesKHR obj;
      obj.supportedAlpha = supportedAlpha;
      obj.minSrcPosition = minSrcPosition;
      obj.maxSrcPosition = maxSrcPosition;
      obj.minSrcExtent = minSrcExtent;
      obj.maxSrcExtent = maxSrcExtent;
      obj.minDstPosition = minDstPosition;
      obj.maxDstPosition = maxDstPosition;
      obj.minDstExtent = minDstExtent;
      obj.maxDstExtent = maxDstExtent;
      return obj;
   }

VkDisplayPlanePropertiesKHR DisplayPlanePropertiesKHR(
    VkDisplayKHR                                currentDisplay,
    uint32_t                                    currentStackIndex)
   {
      VkDisplayPlanePropertiesKHR obj;
      obj.currentDisplay = currentDisplay;
      obj.currentStackIndex = currentStackIndex;
      return obj;
   }

VkDisplaySurfaceCreateInfoKHR DisplaySurfaceCreateInfoKHR(
    VkDisplaySurfaceCreateFlagsKHR              flags,
    VkDisplayModeKHR                            displayMode,
    uint32_t                                    planeIndex,
    uint32_t                                    planeStackIndex,
    VkSurfaceTransformFlagBitsKHR               transform,
    float                                       globalAlpha,
    VkDisplayPlaneAlphaFlagBitsKHR              alphaMode,
    VkExtent2D                                  imageExtent)
   {
      VkDisplaySurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.displayMode = displayMode;
      obj.planeIndex = planeIndex;
      obj.planeStackIndex = planeStackIndex;
      obj.transform = transform;
      obj.globalAlpha = globalAlpha;
      obj.alphaMode = alphaMode;
      obj.imageExtent = imageExtent;
      return obj;
   }

std::vector< VkDisplayPropertiesKHR > getPhysicalDeviceDisplayPropertiesKHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceDisplayPropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayPropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetPhysicalDeviceDisplayPropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetPhysicalDeviceDisplayPropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkDisplayPlanePropertiesKHR > getPhysicalDeviceDisplayPlanePropertiesKHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayPlanePropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkDisplayKHR > getDisplayPlaneSupportedDisplaysKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t planeIndex)
   {
      if ( nullptr == pfvkGetDisplayPlaneSupportedDisplaysKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayKHR> vecpDisplays; 
      uint32_t pDisplaysCount; 
      V( pfvkGetDisplayPlaneSupportedDisplaysKHR(
          physicalDevice,
          planeIndex,
          &pDisplaysCount,
          nullptr  ));

      vecpDisplays.resize(pDisplaysCount); 

      V( pfvkGetDisplayPlaneSupportedDisplaysKHR(
          physicalDevice,
          planeIndex,
          &pDisplaysCount,
          &vecpDisplays[0]  ));
      return vecpDisplays; 
   }

std::vector< VkDisplayModePropertiesKHR > getDisplayModePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display)
   {
      if ( nullptr == pfvkGetDisplayModePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayModePropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetDisplayModePropertiesKHR(
          physicalDevice,
          display,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetDisplayModePropertiesKHR(
          physicalDevice,
          display,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::shared_ptr<VkDisplayModeKHR_T> createDisplayModeKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        const VkDisplayModeCreateInfoKHR & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDisplayModeKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDisplayModeKHR hMode; 
      V( pfvkCreateDisplayModeKHR(
          physicalDevice,
          display,
          &pCreateInfo,
          nullptr,
          &hMode  ));
      return std::shared_ptr<VkDisplayModeKHR_T>(hMode, 
              [](VkDisplayModeKHR) {});
   }

VkDisplayPlaneCapabilitiesKHR getDisplayPlaneCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayModeKHR mode,
        uint32_t planeIndex)
   {
      if ( nullptr == pfvkGetDisplayPlaneCapabilitiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDisplayPlaneCapabilitiesKHR pCapabilities; 
      V( pfvkGetDisplayPlaneCapabilitiesKHR(
          physicalDevice,
          mode,
          planeIndex,
          &pCapabilities  ));
      return pCapabilities; 
   }

std::shared_ptr<VkSurfaceKHR_T> createDisplayPlaneSurfaceKHR(
        VkInstance instance,
        const VkDisplaySurfaceCreateInfoKHR & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDisplayPlaneSurfaceKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSurfaceKHR hSurface; 
      V( pfvkCreateDisplayPlaneSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {vkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

VkDisplayPresentInfoKHR DisplayPresentInfoKHR(
    VkRect2D                                    srcRect,
    VkRect2D                                    dstRect,
    VkBool32                                    persistent)
   {
      VkDisplayPresentInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
      obj.pNext = nullptr;
      obj.srcRect = srcRect;
      obj.dstRect = dstRect;
      obj.persistent = persistent;
      return obj;
   }

std::vector< std::shared_ptr<VkSwapchainKHR_T> > createSharedSwapchainsKHR(
        VkDevice device,
        const std::vector<VkSwapchainCreateInfoKHR> & pCreateInfos)
   {
      if ( nullptr == pfvkCreateSharedSwapchainsKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkSwapchainKHR> vecpSwapchains( pCreateInfos.size(), nullptr ); 
      V( pfvkCreateSharedSwapchainsKHR(
          device,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpSwapchains[0]  ));
      std::vector< std::shared_ptr<VkSwapchainKHR_T> > retval; 
      retval.reserve(vecpSwapchains.size()); 
      for (auto allocated_handle : vecpSwapchains ) 
      {
          retval.push_back(std::shared_ptr<VkSwapchainKHR_T>(allocated_handle, 
              [](VkSwapchainKHR) {}));
      }
      return retval; 
   }

#ifdef VK_USE_PLATFORM_XLIB_KHR
VkXlibSurfaceCreateInfoKHR XlibSurfaceCreateInfoKHR(
    VkXlibSurfaceCreateFlagsKHR                 flags,
    Display*                                    dpy,
    Window                                      window)
   {
      VkXlibSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.dpy = dpy;
      obj.window = window;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createXlibSurfaceKHR(
        VkInstance instance,
        const VkXlibSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateXlibSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {vkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

std::shared_ptr< Display > getPhysicalDeviceXlibPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VisualID visualID)
   {
      std::shared_ptr<Display> ptrdpy(new Display); 
      vkGetPhysicalDeviceXlibPresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          ptrdpy.get(),
          visualID  );
      return ptrdpy; 
   }

#endif /* VK_USE_PLATFORM_XLIB_KHR*/
#ifdef VK_USE_PLATFORM_XCB_KHR
VkXcbSurfaceCreateInfoKHR XcbSurfaceCreateInfoKHR(
    VkXcbSurfaceCreateFlagsKHR                  flags,
    xcb_connection_t*                           connection,
    xcb_window_t                                window)
   {
      VkXcbSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.connection = connection;
      obj.window = window;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createXcbSurfaceKHR(
        VkInstance instance,
        const VkXcbSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateXcbSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {vkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

std::shared_ptr< xcb_connection_t > getPhysicalDeviceXcbPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        xcb_visualid_t visual_id)
   {
      std::shared_ptr<xcb_connection_t> ptrconnection(new xcb_connection_t); 
      vkGetPhysicalDeviceXcbPresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          ptrconnection.get(),
          visual_id  );
      return ptrconnection; 
   }

#endif /* VK_USE_PLATFORM_XCB_KHR*/
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
VkWaylandSurfaceCreateInfoKHR WaylandSurfaceCreateInfoKHR(
    VkWaylandSurfaceCreateFlagsKHR              flags,
    struct wl_display*                          display,
    struct wl_surface*                          surface)
   {
      VkWaylandSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.display = display;
      obj.surface = surface;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createWaylandSurfaceKHR(
        VkInstance instance,
        const VkWaylandSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateWaylandSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {vkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

std::shared_ptr< wl_display > getPhysicalDeviceWaylandPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex)
   {
      std::shared_ptr<wl_display> ptrdisplay(new wl_display); 
      vkGetPhysicalDeviceWaylandPresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          ptrdisplay.get()  );
      return ptrdisplay; 
   }

#endif /* VK_USE_PLATFORM_WAYLAND_KHR*/
#ifdef VK_USE_PLATFORM_MIR_KHR
VkMirSurfaceCreateInfoKHR MirSurfaceCreateInfoKHR(
    VkMirSurfaceCreateFlagsKHR                  flags,
    MirConnection*                              connection,
    MirSurface*                                 mirSurface)
   {
      VkMirSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.connection = connection;
      obj.mirSurface = mirSurface;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createMirSurfaceKHR(
        VkInstance instance,
        const VkMirSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateMirSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {vkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

std::shared_ptr< MirConnection > getPhysicalDeviceMirPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex)
   {
      std::shared_ptr<MirConnection> ptrconnection(new MirConnection); 
      vkGetPhysicalDeviceMirPresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          ptrconnection.get()  );
      return ptrconnection; 
   }

#endif /* VK_USE_PLATFORM_MIR_KHR*/
#ifdef VK_USE_PLATFORM_ANDROID_KHR
VkAndroidSurfaceCreateInfoKHR AndroidSurfaceCreateInfoKHR(
    VkAndroidSurfaceCreateFlagsKHR              flags,
    ANativeWindow*                              window)
   {
      VkAndroidSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.window = window;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createAndroidSurfaceKHR(
        VkInstance instance,
        const VkAndroidSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateAndroidSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {vkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

#endif /* VK_USE_PLATFORM_ANDROID_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
VkWin32SurfaceCreateInfoKHR Win32SurfaceCreateInfoKHR(
    VkWin32SurfaceCreateFlagsKHR                flags,
    HINSTANCE                                   hinstance,
    HWND                                        hwnd)
   {
      VkWin32SurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.hinstance = hinstance;
      obj.hwnd = hwnd;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createWin32SurfaceKHR(
        VkInstance instance,
        const VkWin32SurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateWin32SurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {vkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

void  getPhysicalDeviceWin32PresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex)
   {
      vkGetPhysicalDeviceWin32PresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex  );
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
VkDebugReportCallbackCreateInfoEXT DebugReportCallbackCreateInfoEXT(
    VkDebugReportFlagsEXT                       flags,
    PFN_vkDebugReportCallbackEXT                pfnCallback)
   {
      VkDebugReportCallbackCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.pfnCallback = pfnCallback;
      obj.pUserData = nullptr;
      return obj;
   }

std::shared_ptr<VkDebugReportCallbackEXT_T> createDebugReportCallbackEXT(
        VkInstance instance,
        const VkDebugReportCallbackCreateInfoEXT & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDebugReportCallbackEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDebugReportCallbackEXT hCallback; 
      V( pfvkCreateDebugReportCallbackEXT(
          instance,
          &pCreateInfo,
          nullptr,
          &hCallback  ));
      return std::shared_ptr<VkDebugReportCallbackEXT_T>(hCallback, 
              [=](VkDebugReportCallbackEXT to_free) {pfvkDestroyDebugReportCallbackEXT(instance, to_free, nullptr);});
   }

void  debugReportMessageEXT(
        VkInstance instance,
        VkDebugReportFlagsEXT flags,
        VkDebugReportObjectTypeEXT objectType,
        uint64_t object,
        size_t location,
        int32_t messageCode,
        const char* pLayerPrefix,
        const char* pMessage)
   {
      if ( nullptr == pfvkDebugReportMessageEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkDebugReportMessageEXT(
          instance,
          flags,
          objectType,
          object,
          location,
          messageCode,
          pLayerPrefix,
          pMessage  );
   }

VkPipelineRasterizationStateRasterizationOrderAMD PipelineRasterizationStateRasterizationOrderAMD(
    VkRasterizationOrderAMD                     rasterizationOrder)
   {
      VkPipelineRasterizationStateRasterizationOrderAMD obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
      obj.pNext = nullptr;
      obj.rasterizationOrder = rasterizationOrder;
      return obj;
   }

struct VkDebugMarkerObjectNameInfoEXTRAII {
   VkDebugMarkerObjectNameInfoEXT nonRaiiObj;
    std::string                                 strObjectName;
};

std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII> DebugMarkerObjectNameInfoEXT(
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    const std::string &                         strObjectName)
   {
      std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII> raii_obj(new VkDebugMarkerObjectNameInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.objectType = objectType;
      raii_obj->nonRaiiObj.object = object;
      raii_obj->strObjectName = strObjectName;
      raii_obj->nonRaiiObj.pObjectName = &raii_obj->strObjectName[0];
      return raii_obj;
   }

VkDebugMarkerObjectTagInfoEXT DebugMarkerObjectTagInfoEXT(
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    uint64_t                                    tagName,
    size_t                                      tagSize)
   {
      VkDebugMarkerObjectTagInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
      obj.pNext = nullptr;
      obj.objectType = objectType;
      obj.object = object;
      obj.tagName = tagName;
      obj.tagSize = tagSize;
      obj.pTag = nullptr;
      return obj;
   }

struct VkDebugMarkerMarkerInfoEXTRAII {
   VkDebugMarkerMarkerInfoEXT nonRaiiObj;
    std::string                                 strMarkerName;
};

std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII> DebugMarkerMarkerInfoEXT(
    const std::string &                         strMarkerName,
    float                                       color[4])
   {
      std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII> raii_obj(new VkDebugMarkerMarkerInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->strMarkerName = strMarkerName;
      raii_obj->nonRaiiObj.pMarkerName = &raii_obj->strMarkerName[0];
      std::copy(color, color + 4, raii_obj->nonRaiiObj.color);
      return raii_obj;
   }

VkDebugMarkerObjectTagInfoEXT debugMarkerSetObjectTagEXT(
        VkDevice device)
   {
      if ( nullptr == pfvkDebugMarkerSetObjectTagEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDebugMarkerObjectTagInfoEXT pTagInfo; 
      V( pfvkDebugMarkerSetObjectTagEXT(
          device,
          &pTagInfo  ));
      return pTagInfo; 
   }

std::shared_ptr< VkDebugMarkerObjectNameInfoEXT > debugMarkerSetObjectNameEXT(
        VkDevice device)
   {
      if ( nullptr == pfvkDebugMarkerSetObjectNameEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::shared_ptr<VkDebugMarkerObjectNameInfoEXT> ptrpNameInfo(new VkDebugMarkerObjectNameInfoEXT); 
      V( pfvkDebugMarkerSetObjectNameEXT(
          device,
          ptrpNameInfo.get()  ));
      return ptrpNameInfo; 
   }

std::shared_ptr< VkDebugMarkerMarkerInfoEXT > cmdDebugMarkerBeginEXT(
        VkCommandBuffer commandBuffer)
   {
      if ( nullptr == pfvkCmdDebugMarkerBeginEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::shared_ptr<VkDebugMarkerMarkerInfoEXT> ptrpMarkerInfo(new VkDebugMarkerMarkerInfoEXT); 
      pfvkCmdDebugMarkerBeginEXT(
          commandBuffer,
          ptrpMarkerInfo.get()  );
      return ptrpMarkerInfo; 
   }

void  cmdDebugMarkerEndEXT(
        VkCommandBuffer commandBuffer)
   {
      if ( nullptr == pfvkCmdDebugMarkerEndEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDebugMarkerEndEXT(
          commandBuffer  );
   }

std::shared_ptr< VkDebugMarkerMarkerInfoEXT > cmdDebugMarkerInsertEXT(
        VkCommandBuffer commandBuffer)
   {
      if ( nullptr == pfvkCmdDebugMarkerInsertEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::shared_ptr<VkDebugMarkerMarkerInfoEXT> ptrpMarkerInfo(new VkDebugMarkerMarkerInfoEXT); 
      pfvkCmdDebugMarkerInsertEXT(
          commandBuffer,
          ptrpMarkerInfo.get()  );
      return ptrpMarkerInfo; 
   }

VkDedicatedAllocationImageCreateInfoNV DedicatedAllocationImageCreateInfoNV(
    VkBool32                                    dedicatedAllocation)
   {
      VkDedicatedAllocationImageCreateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
      obj.pNext = nullptr;
      obj.dedicatedAllocation = dedicatedAllocation;
      return obj;
   }

VkDedicatedAllocationBufferCreateInfoNV DedicatedAllocationBufferCreateInfoNV(
    VkBool32                                    dedicatedAllocation)
   {
      VkDedicatedAllocationBufferCreateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
      obj.pNext = nullptr;
      obj.dedicatedAllocation = dedicatedAllocation;
      return obj;
   }

VkDedicatedAllocationMemoryAllocateInfoNV DedicatedAllocationMemoryAllocateInfoNV(
    VkImage                                     image,
    VkBuffer                                    buffer)
   {
      VkDedicatedAllocationMemoryAllocateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
      obj.pNext = nullptr;
      obj.image = image;
      obj.buffer = buffer;
      return obj;
   }

void  cmdDrawIndirectCountAMD(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride)
   {
      if ( nullptr == pfvkCmdDrawIndirectCountAMD )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDrawIndirectCountAMD(
          commandBuffer,
          buffer,
          offset,
          countBuffer,
          countBufferOffset,
          maxDrawCount,
          stride  );
   }

void  cmdDrawIndexedIndirectCountAMD(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride)
   {
      if ( nullptr == pfvkCmdDrawIndexedIndirectCountAMD )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDrawIndexedIndirectCountAMD(
          commandBuffer,
          buffer,
          offset,
          countBuffer,
          countBufferOffset,
          maxDrawCount,
          stride  );
   }

VkExternalImageFormatPropertiesNV ExternalImageFormatPropertiesNV(
    VkImageFormatProperties                     imageFormatProperties,
    VkExternalMemoryFeatureFlagsNV              externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlagsNV           exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlagsNV           compatibleHandleTypes)
   {
      VkExternalImageFormatPropertiesNV obj;
      obj.imageFormatProperties = imageFormatProperties;
      obj.externalMemoryFeatures = externalMemoryFeatures;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      return obj;
   }

VkExternalImageFormatPropertiesNV getPhysicalDeviceExternalImageFormatPropertiesNV(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags,
        VkExternalMemoryHandleTypeFlagsNV externalHandleType)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalImageFormatPropertiesNV )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalImageFormatPropertiesNV pExternalImageFormatProperties; 
      V( pfvkGetPhysicalDeviceExternalImageFormatPropertiesNV(
          physicalDevice,
          format,
          type,
          tiling,
          usage,
          flags,
          externalHandleType,
          &pExternalImageFormatProperties  ));
      return pExternalImageFormatProperties; 
   }

VkExternalMemoryImageCreateInfoNV ExternalMemoryImageCreateInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleTypes)
   {
      VkExternalMemoryImageCreateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExportMemoryAllocateInfoNV ExportMemoryAllocateInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleTypes)
   {
      VkExportMemoryAllocateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

#ifdef VK_USE_PLATFORM_WIN32_KHR
VkImportMemoryWin32HandleInfoNV ImportMemoryWin32HandleInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE                                      handle)
   {
      VkImportMemoryWin32HandleInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      obj.handle = handle;
      return obj;
   }

struct VkExportMemoryWin32HandleInfoNVRAII {
   VkExportMemoryWin32HandleInfoNV nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> ExportMemoryWin32HandleInfoNV(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess)
   {
      std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> raii_obj(new VkExportMemoryWin32HandleInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      return raii_obj;
   }

std::shared_ptr< HANDLE > getMemoryWin32HandleNV(
        VkDevice device,
        VkDeviceMemory memory,
        VkExternalMemoryHandleTypeFlagsNV handleType)
   {
      if ( nullptr == pfvkGetMemoryWin32HandleNV )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::shared_ptr<HANDLE> ptrpHandle(new HANDLE); 
      V( pfvkGetMemoryWin32HandleNV(
          device,
          memory,
          handleType,
          ptrpHandle.get()  ));
      return ptrpHandle; 
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
struct VkWin32KeyedMutexAcquireReleaseInfoNVRAII {
   VkWin32KeyedMutexAcquireReleaseInfoNV nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeoutMilliseconds;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};

std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> Win32KeyedMutexAcquireReleaseInfoNV(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeoutMilliseconds_in_array1, int pAcquireTimeoutMilliseconds_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys)
   {
      std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> raii_obj(new VkWin32KeyedMutexAcquireReleaseInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.acquireCount = static_cast<uint32_t>(vecAcquireSyncs.size());
      raii_obj->vecAcquireSyncs = vecAcquireSyncs;
      if ( raii_obj->vecAcquireSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = &raii_obj->vecAcquireSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = nullptr;
      }
      raii_obj->vecAcquireKeys = vecAcquireKeys;
      if ( raii_obj->vecAcquireKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireKeys = &raii_obj->vecAcquireKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireKeys = nullptr;
      }
      raii_obj->vecAcquireTimeoutMilliseconds.assign(pAcquireTimeoutMilliseconds_in_array1, pAcquireTimeoutMilliseconds_in_array1 + pAcquireTimeoutMilliseconds_dim1);
      if ( raii_obj->vecAcquireTimeoutMilliseconds.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireTimeoutMilliseconds = &raii_obj->vecAcquireTimeoutMilliseconds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireTimeoutMilliseconds = nullptr;
      }
      raii_obj->nonRaiiObj.releaseCount = static_cast<uint32_t>(vecReleaseSyncs.size());
      raii_obj->vecReleaseSyncs = vecReleaseSyncs;
      if ( raii_obj->vecReleaseSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = &raii_obj->vecReleaseSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = nullptr;
      }
      raii_obj->vecReleaseKeys = vecReleaseKeys;
      if ( raii_obj->vecReleaseKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseKeys = &raii_obj->vecReleaseKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseKeys = nullptr;
      }
      return raii_obj;
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
struct VkValidationFlagsEXTRAII {
   VkValidationFlagsEXT nonRaiiObj;
    std::vector<VkValidationCheckEXT>           vecDisabledValidationChecks;
};

std::shared_ptr<VkValidationFlagsEXTRAII> ValidationFlagsEXT(
    const std::vector<VkValidationCheckEXT> &   vecDisabledValidationChecks)
   {
      std::shared_ptr<VkValidationFlagsEXTRAII> raii_obj(new VkValidationFlagsEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.disabledValidationCheckCount = static_cast<uint32_t>(vecDisabledValidationChecks.size());
      raii_obj->vecDisabledValidationChecks = vecDisabledValidationChecks;
      if ( raii_obj->vecDisabledValidationChecks.size() > 0)
      {
          raii_obj->nonRaiiObj.pDisabledValidationChecks = &raii_obj->vecDisabledValidationChecks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDisabledValidationChecks = nullptr;
      }
      return raii_obj;
   }
%}

%template (VkDeviceCreateInfoPtr) std::shared_ptr<VkDeviceCreateInfoRAII>;

%template (VkValidationFlagsEXTPtr) std::shared_ptr<VkValidationFlagsEXTRAII>;

%template (VkInstanceCreateInfoPtr) std::shared_ptr<VkInstanceCreateInfoRAII>;

%template (VkWin32KeyedMutexAcquireReleaseInfoNVPtr) std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII>;

%template (VkSparseBufferMemoryBindInfoPtr) std::shared_ptr<VkSparseBufferMemoryBindInfoRAII>;

%template (VkDisplayPropertiesKHRPtr) std::shared_ptr<VkDisplayPropertiesKHRRAII>;

%template (VkDebugMarkerMarkerInfoEXTPtr) std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII>;

%template (VkSwapchainCreateInfoKHRPtr) std::shared_ptr<VkSwapchainCreateInfoKHRRAII>;

%template (VkPipelineColorBlendStateCreateInfoPtr) std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>;

%template (VkBindSparseInfoPtr) std::shared_ptr<VkBindSparseInfoRAII>;

%template (VkBufferCreateInfoPtr) std::shared_ptr<VkBufferCreateInfoRAII>;

%template (VkDescriptorSetAllocateInfoPtr) std::shared_ptr<VkDescriptorSetAllocateInfoRAII>;

%template (VkExportMemoryWin32HandleInfoNVPtr) std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII>;

%template (VkPipelineDynamicStateCreateInfoPtr) std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>;

%template (VkSparseImageOpaqueMemoryBindInfoPtr) std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII>;

%template (VkSubpassDescriptionPtr) std::shared_ptr<VkSubpassDescriptionRAII>;

%template (VkCommandBufferBeginInfoPtr) std::shared_ptr<VkCommandBufferBeginInfoRAII>;

%template (VkPipelineVertexInputStateCreateInfoPtr) std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>;

%template (VkDescriptorSetLayoutCreateInfoPtr) std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII>;

%template (VkSparseImageMemoryBindInfoPtr) std::shared_ptr<VkSparseImageMemoryBindInfoRAII>;

%template (VkImageCreateInfoPtr) std::shared_ptr<VkImageCreateInfoRAII>;

%template (VkDescriptorPoolCreateInfoPtr) std::shared_ptr<VkDescriptorPoolCreateInfoRAII>;

%template (VkDeviceQueueCreateInfoPtr) std::shared_ptr<VkDeviceQueueCreateInfoRAII>;

%template (VkPipelineShaderStageCreateInfoPtr) std::shared_ptr<VkPipelineShaderStageCreateInfoRAII>;

%template (VkPipelineViewportStateCreateInfoPtr) std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>;

%template (VkSubmitInfoPtr) std::shared_ptr<VkSubmitInfoRAII>;

%template (VkRenderPassCreateInfoPtr) std::shared_ptr<VkRenderPassCreateInfoRAII>;

%template (VkPresentInfoKHRPtr) std::shared_ptr<VkPresentInfoKHRRAII>;

%template (VkWriteDescriptorSetPtr) std::shared_ptr<VkWriteDescriptorSetRAII>;

%template (VkSpecializationInfoPtr) std::shared_ptr<VkSpecializationInfoRAII>;

%template (VkDescriptorSetLayoutBindingPtr) std::shared_ptr<VkDescriptorSetLayoutBindingRAII>;

%template (VkApplicationInfoPtr) std::shared_ptr<VkApplicationInfoRAII>;

%template (VkPipelineLayoutCreateInfoPtr) std::shared_ptr<VkPipelineLayoutCreateInfoRAII>;

%template (VkDebugMarkerObjectNameInfoEXTPtr) std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII>;

%template (VkRenderPassBeginInfoPtr) std::shared_ptr<VkRenderPassBeginInfoRAII>;

%template (VkGraphicsPipelineCreateInfoPtr) std::shared_ptr<VkGraphicsPipelineCreateInfoRAII>;

%template (VkFramebufferCreateInfoPtr) std::shared_ptr<VkFramebufferCreateInfoRAII>;

%template (VkSpecializationMapEntryVector) std::vector<VkSpecializationMapEntry>;

%template (VkDisplayModePropertiesKHRVector) std::vector<VkDisplayModePropertiesKHR>;

%template (VkBufferVector) std::vector<VkBuffer>;

%template (VkBufferImageCopyVector) std::vector<VkBufferImageCopy>;

%template (VkComputePipelineCreateInfoVector) std::vector<VkComputePipelineCreateInfo>;

%template (floatVector) std::vector<float>;

%template (VkDescriptorImageInfoVector) std::vector<VkDescriptorImageInfo>;

%template (VkExtensionPropertiesVector) std::vector<VkExtensionProperties>;

%template (VkSwapchainCreateInfoKHRVector) std::vector< std::shared_ptr<VkSwapchainCreateInfoKHRRAII> >;

%template (VkResultVector) std::vector<VkResult>;

%template (VkPipelineCacheVector) std::vector<VkPipelineCache>;

%template (VkImageBlitVector) std::vector<VkImageBlit>;

%template (VkDeviceSizeVector) std::vector<VkDeviceSize>;

%template (VkBindSparseInfoVector) std::vector< std::shared_ptr<VkBindSparseInfoRAII> >;

%template (VkDeviceMemoryVector) std::vector<VkDeviceMemory>;

%template (VkDisplayPropertiesKHRVector) std::vector< std::shared_ptr<VkDisplayPropertiesKHRRAII> >;

%template (VkBufferMemoryBarrierVector) std::vector<VkBufferMemoryBarrier>;

%template (VkSparseImageOpaqueMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> >;

%template (VkPipelineColorBlendAttachmentStateVector) std::vector<VkPipelineColorBlendAttachmentState>;

%template (VkEventVector) std::vector<VkEvent>;

%template (VkBufferCopyVector) std::vector<VkBufferCopy>;

%template (VkDescriptorPoolSizeVector) std::vector<VkDescriptorPoolSize>;

%template (VkSubpassDescriptionVector) std::vector< std::shared_ptr<VkSubpassDescriptionRAII> >;

%template (VkSubmitInfoVector) std::vector< std::shared_ptr<VkSubmitInfoRAII> >;

%template (VkSwapchainKHRVector) std::vector<VkSwapchainKHR>;

%template (VkWriteDescriptorSetVector) std::vector< std::shared_ptr<VkWriteDescriptorSetRAII> >;

%template (VkCopyDescriptorSetVector) std::vector<VkCopyDescriptorSet>;

%template (VkPipelineVector) std::vector<VkPipeline>;

%template (VkDisplayKHRVector) std::vector<VkDisplayKHR>;

%template (VkRect2DVector) std::vector<VkRect2D>;

%template (VkMemoryBarrierVector) std::vector<VkMemoryBarrier>;

%template (VkMappedMemoryRangeVector) std::vector<VkMappedMemoryRange>;

%template (VkAttachmentReferenceVector) std::vector<VkAttachmentReference>;

%template (VkSparseImageMemoryRequirementsVector) std::vector<VkSparseImageMemoryRequirements>;

%template (VkSurfaceFormatKHRVector) std::vector<VkSurfaceFormatKHR>;

%template (VkSparseImageMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseImageMemoryBindInfoRAII> >;

%template (VkDisplayPlanePropertiesKHRVector) std::vector<VkDisplayPlanePropertiesKHR>;

%template (VkDeviceQueueCreateInfoVector) std::vector< std::shared_ptr<VkDeviceQueueCreateInfoRAII> >;

%template (VkSemaphoreVector) std::vector<VkSemaphore>;

%template (VkSparseMemoryBindVector) std::vector<VkSparseMemoryBind>;

%template (VkPresentModeKHRVector) std::vector<VkPresentModeKHR>;

%template (VkPipelineShaderStageCreateInfoVector) std::vector< std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> >;

%template (VkSubpassDependencyVector) std::vector<VkSubpassDependency>;

%template (VkDescriptorSetLayoutBindingVector) std::vector< std::shared_ptr<VkDescriptorSetLayoutBindingRAII> >;

%template (VkImageCopyVector) std::vector<VkImageCopy>;

%template (VkDescriptorBufferInfoVector) std::vector<VkDescriptorBufferInfo>;

%template (VkViewportVector) std::vector<VkViewport>;

%template (VkPipelineStageFlagsVector) std::vector<VkPipelineStageFlags>;

%template (VkDescriptorSetLayoutVector) std::vector<VkDescriptorSetLayout>;

%template (VkClearAttachmentVector) std::vector<VkClearAttachment>;

%template (VkAttachmentDescriptionVector) std::vector<VkAttachmentDescription>;

%template (VkSparseBufferMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> >;

%template (VkQueueFamilyPropertiesVector) std::vector<VkQueueFamilyProperties>;

%template (VkSparseImageFormatPropertiesVector) std::vector<VkSparseImageFormatProperties>;

%template (VkPhysicalDeviceVector) std::vector<VkPhysicalDevice>;

%template (VkValidationCheckEXTVector) std::vector<VkValidationCheckEXT>;

%template (VkLayerPropertiesVector) std::vector<VkLayerProperties>;

%template (VkFenceVector) std::vector<VkFence>;

%template (VkClearRectVector) std::vector<VkClearRect>;

%template (VkImageVector) std::vector<VkImage>;

%template (VkImageResolveVector) std::vector<VkImageResolve>;

%template (VkSamplerVector) std::vector<VkSampler>;

%template (VkVertexInputAttributeDescriptionVector) std::vector<VkVertexInputAttributeDescription>;

%template (VkImageViewVector) std::vector<VkImageView>;

%template (VkImageMemoryBarrierVector) std::vector<VkImageMemoryBarrier>;

%template (VkPushConstantRangeVector) std::vector<VkPushConstantRange>;

%template (VkClearValueVector) std::vector<VkClearValue>;

%template (VkBufferViewVector) std::vector<VkBufferView>;

%template (VkDynamicStateVector) std::vector<VkDynamicState>;

%template (VkImageSubresourceRangeVector) std::vector<VkImageSubresourceRange>;

%template (VkGraphicsPipelineCreateInfoVector) std::vector< std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> >;

%template (VkVertexInputBindingDescriptionVector) std::vector<VkVertexInputBindingDescription>;

%template (VkSparseImageMemoryBindVector) std::vector<VkSparseImageMemoryBind>;

%template (VkSwapchainKHRHandleVector) std::vector< std::shared_ptr< VkSwapchainKHR_T > >;

%template (VkPipelineHandleVector) std::vector< std::shared_ptr< VkPipeline_T > >;

// Skipped commands that must be manually wrapped
//vkGetInstanceProcAddr
//vkGetDeviceProcAddr
//vkMapMemory
//vkAllocateDescriptorSets
//vkAllocateCommandBuffers
// End content generated by genswigi.py
